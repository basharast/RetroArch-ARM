diff --git a/deps/glslang/glslang/SPIRV/doc.h b/deps/glslang/glslang/SPIRV/doc.h
index 7d0475d3eb..eb6b4b963e 100644
--- a/deps/glslang/glslang/SPIRV/doc.h
+++ b/deps/glslang/glslang/SPIRV/doc.h
@@ -32,6 +32,9 @@
 // ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 // POSSIBILITY OF SUCH DAMAGE.
 
+#ifndef _SPIRV_doc_h
+#define _SPIRV_doc_h
+
 //
 // Parameterize the SPIR-V enumerants.
 //
@@ -256,3 +259,5 @@ const char* AccessQualifierString(int attr);
 void PrintOperands(const OperandParameters& operands, int reservedOperands);
 
 };  // end namespace spv
+
+#endif
diff --git a/deps/glslang/glslang/glslang/MachineIndependent/LiveTraverser.h b/deps/glslang/glslang/glslang/MachineIndependent/LiveTraverser.h
index 7333bc964e..fcb1fa9bb7 100644
--- a/deps/glslang/glslang/glslang/MachineIndependent/LiveTraverser.h
+++ b/deps/glslang/glslang/glslang/MachineIndependent/LiveTraverser.h
@@ -33,6 +33,9 @@
 // POSSIBILITY OF SUCH DAMAGE.
 //
 
+#ifndef _MACHINE_INDEPENDENT_LIVE_TRAVERSER_H
+#define _MACHINE_INDEPENDENT_LIVE_TRAVERSER_H
+
 #pragma once
 
 #include "../Include/Common.h"
@@ -136,3 +139,5 @@ private:
 };
 
 } // namespace glslang
+
+#endif
diff --git a/deps/glslang/glslang/glslang/MachineIndependent/Scan.cpp b/deps/glslang/glslang/glslang/MachineIndependent/Scan.cpp
index aa21d8a11e..0464f965fd 100755
--- a/deps/glslang/glslang/glslang/MachineIndependent/Scan.cpp
+++ b/deps/glslang/glslang/glslang/MachineIndependent/Scan.cpp
@@ -54,6 +54,7 @@
 // preprocessor includes
 #include "preprocessor/PpContext.h"
 #include "preprocessor/PpTokens.h"
+#include "preprocessor/Compare.h"
 
 // Required to avoid missing prototype warnings for some compilers
 int yylex(YYSTYPE*, glslang::TParseContext&);
@@ -289,38 +290,15 @@ protected:
 } // end namespace glslang
 
 // This is the function the glslang parser (i.e., bison) calls to get its next token
-int yylex(YYSTYPE* glslangTokenDesc, glslang::TParseContext& parseContext)
+int yylex(YYSTYPE* glslangTokenDesc, glslang::TParseContext& _parseContext)
 {
     glslang::TParserToken token(*glslangTokenDesc);
 
-    return parseContext.getScanContext()->tokenize(parseContext.getPpContext(), token);
+    return _parseContext.getScanContext()->tokenize(_parseContext.getPpContext(), token);
 }
 
 namespace {
 
-struct str_eq
-{
-    bool operator()(const char* lhs, const char* rhs) const
-    {
-        return strcmp(lhs, rhs) == 0;
-    }
-};
-
-struct str_hash
-{
-    size_t operator()(const char* str) const
-    {
-        // djb2
-        unsigned long hash = 5381;
-        int c;
-
-        while ((c = *str++) != 0)
-            hash = ((hash << 5) + hash) + c;
-
-        return hash;
-    }
-};
-
 // A single global usable by all threads, by all versions, by all languages.
 // After a single process-level initialization, this is read only and thread safe
 std::unordered_map<const char*, int, str_hash, str_eq>* KeywordMap = nullptr;
@@ -781,7 +759,7 @@ int TScanContext::tokenize(TPpContext* pp, TParserToken& token)
         case '{':  afterStruct = false; return LEFT_BRACE;
         case '}':                       return RIGHT_BRACE;
         case '\\':
-            parseContext.error(loc, "illegal use of escape character", "\\", "");
+            _parseContext.error(loc, "illegal use of escape character", "\\", "");
             break;
 
         case PPAtomAddAssign:          return ADD_ASSIGN;
@@ -812,7 +790,7 @@ int TScanContext::tokenize(TPpContext* pp, TParserToken& token)
         case PpAtomIncrement:          return INC_OP;
 
         case PpAtomColonColon:
-            parseContext.error(loc, "not supported", "::", "");
+            _parseContext.error(loc, "not supported", "::", "");
             break;
 
         case PpAtomConstInt:           parserToken->sType.lex.i    = ppToken.ival;       return INTCONSTANT;
@@ -837,7 +815,7 @@ int TScanContext::tokenize(TPpContext* pp, TParserToken& token)
             char buf[2];
             buf[0] = (char)token;
             buf[1] = 0;
-            parseContext.error(loc, "unexpected token", buf, "");
+            _parseContext.error(loc, "unexpected token", buf, "");
             break;
         }
     } while (true);
@@ -878,15 +856,15 @@ int TScanContext::tokenizeIdentifier()
         return keyword;
 
     case NONUNIFORM:
-        if (parseContext.extensionTurnedOn(E_GL_EXT_nonuniform_qualifier))
+        if (_parseContext.extensionTurnedOn(E_GL_EXT_nonuniform_qualifier))
             return keyword;
         else
             return identifierOrType();
 
     case SWITCH:
     case DEFAULT:
-        if ((parseContext.profile == EEsProfile && parseContext.version < 300) ||
-            (parseContext.profile != EEsProfile && parseContext.version < 130))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version < 300) ||
+            (_parseContext.profile != EEsProfile && _parseContext.version < 130))
             reservedWord();
         return keyword;
 
@@ -920,19 +898,19 @@ int TScanContext::tokenizeIdentifier()
 
     case ATTRIBUTE:
     case VARYING:
-        if (parseContext.profile == EEsProfile && parseContext.version >= 300)
+        if (_parseContext.profile == EEsProfile && _parseContext.version >= 300)
             reservedWord();
         return keyword;
 
     case BUFFER:
-        if ((parseContext.profile == EEsProfile && parseContext.version < 310) ||
-            (parseContext.profile != EEsProfile && parseContext.version < 430))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version < 310) ||
+            (_parseContext.profile != EEsProfile && _parseContext.version < 430))
             return identifierOrType();
         return keyword;
 
     case ATOMIC_UINT:
-        if ((parseContext.profile == EEsProfile && parseContext.version >= 310) ||
-            parseContext.extensionTurnedOn(E_GL_ARB_shader_atomic_counters))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version >= 310) ||
+            _parseContext.extensionTurnedOn(E_GL_ARB_shader_atomic_counters))
             return keyword;
         return es30ReservedFromGLSL(420);
 
@@ -940,15 +918,15 @@ int TScanContext::tokenizeIdentifier()
     case RESTRICT:
     case READONLY:
     case WRITEONLY:
-        if (parseContext.profile == EEsProfile && parseContext.version >= 310)
+        if (_parseContext.profile == EEsProfile && _parseContext.version >= 310)
             return keyword;
-        return es30ReservedFromGLSL(parseContext.extensionTurnedOn(E_GL_ARB_shader_image_load_store) ? 130 : 420);
+        return es30ReservedFromGLSL(_parseContext.extensionTurnedOn(E_GL_ARB_shader_image_load_store) ? 130 : 420);
 
     case VOLATILE:
-        if (parseContext.profile == EEsProfile && parseContext.version >= 310)
+        if (_parseContext.profile == EEsProfile && _parseContext.version >= 310)
             return keyword;
-        if (! parseContext.symbolTable.atBuiltInLevel() && (parseContext.profile == EEsProfile ||
-            (parseContext.version < 420 && ! parseContext.extensionTurnedOn(E_GL_ARB_shader_image_load_store))))
+        if (! _parseContext.symbolTable.atBuiltInLevel() && (_parseContext.profile == EEsProfile ||
+            (_parseContext.version < 420 && ! _parseContext.extensionTurnedOn(E_GL_ARB_shader_image_load_store))))
             reservedWord();
         return keyword;
 
@@ -957,31 +935,31 @@ int TScanContext::tokenizeIdentifier()
         const int numLayoutExts = 2;
         const char* layoutExts[numLayoutExts] = { E_GL_ARB_shading_language_420pack,
                                                   E_GL_ARB_explicit_attrib_location };
-        if ((parseContext.profile == EEsProfile && parseContext.version < 300) ||
-            (parseContext.profile != EEsProfile && parseContext.version < 140 &&
-            ! parseContext.extensionsTurnedOn(numLayoutExts, layoutExts)))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version < 300) ||
+            (_parseContext.profile != EEsProfile && _parseContext.version < 140 &&
+            ! _parseContext.extensionsTurnedOn(numLayoutExts, layoutExts)))
             return identifierOrType();
         return keyword;
     }
     case SHARED:
-        if ((parseContext.profile == EEsProfile && parseContext.version < 300) ||
-            (parseContext.profile != EEsProfile && parseContext.version < 140))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version < 300) ||
+            (_parseContext.profile != EEsProfile && _parseContext.version < 140))
             return identifierOrType();
         return keyword;
 
     case PATCH:
-        if (parseContext.symbolTable.atBuiltInLevel() ||
-            (parseContext.profile == EEsProfile &&
-             (parseContext.version >= 320 ||
-              parseContext.extensionsTurnedOn(Num_AEP_tessellation_shader, AEP_tessellation_shader))) ||
-            (parseContext.profile != EEsProfile && parseContext.extensionTurnedOn(E_GL_ARB_tessellation_shader)))
+        if (_parseContext.symbolTable.atBuiltInLevel() ||
+            (_parseContext.profile == EEsProfile &&
+             (_parseContext.version >= 320 ||
+              _parseContext.extensionsTurnedOn(Num_AEP_tessellation_shader, AEP_tessellation_shader))) ||
+            (_parseContext.profile != EEsProfile && _parseContext.extensionTurnedOn(E_GL_ARB_tessellation_shader)))
             return keyword;
 
         return es30ReservedFromGLSL(400);
 
     case SAMPLE:
-        if ((parseContext.profile == EEsProfile && parseContext.version >= 320) ||
-            parseContext.extensionsTurnedOn(1, &E_GL_OES_shader_multisample_interpolation))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version >= 320) ||
+            _parseContext.extensionsTurnedOn(1, &E_GL_OES_shader_multisample_interpolation))
             return keyword;
         return es30ReservedFromGLSL(400);
 
@@ -1035,8 +1013,8 @@ int TScanContext::tokenizeIdentifier()
     case IIMAGEBUFFER:
     case UIMAGEBUFFER:
         afterType = true;
-        if ((parseContext.profile == EEsProfile && parseContext.version >= 320) ||
-            parseContext.extensionsTurnedOn(Num_AEP_texture_buffer, AEP_texture_buffer))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version >= 320) ||
+            _parseContext.extensionsTurnedOn(Num_AEP_texture_buffer, AEP_texture_buffer))
             return keyword;
         return firstGenerationImage(false);
 
@@ -1059,8 +1037,8 @@ int TScanContext::tokenizeIdentifier()
     case IIMAGECUBEARRAY:
     case UIMAGECUBEARRAY:
         afterType = true;
-        if ((parseContext.profile == EEsProfile && parseContext.version >= 320) ||
-            parseContext.extensionsTurnedOn(Num_AEP_texture_cube_map_array, AEP_texture_cube_map_array))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version >= 320) ||
+            _parseContext.extensionsTurnedOn(Num_AEP_texture_cube_map_array, AEP_texture_cube_map_array))
             return keyword;
         return secondGenerationImage();
 
@@ -1078,7 +1056,7 @@ int TScanContext::tokenizeIdentifier()
     case DVEC3:
     case DVEC4:
         afterType = true;
-        if (parseContext.profile == EEsProfile || parseContext.version < 400)
+        if (_parseContext.profile == EEsProfile || _parseContext.version < 400)
             reservedWord();
         return keyword;
 
@@ -1091,11 +1069,11 @@ int TScanContext::tokenizeIdentifier()
     case U64VEC3:
     case U64VEC4:
         afterType = true;
-        if (parseContext.symbolTable.atBuiltInLevel() ||
-            (parseContext.profile != EEsProfile && parseContext.version >= 450 &&
-             (parseContext.extensionTurnedOn(E_GL_ARB_gpu_shader_int64) ||
-              parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
-              parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_int64))))
+        if (_parseContext.symbolTable.atBuiltInLevel() ||
+            (_parseContext.profile != EEsProfile && _parseContext.version >= 450 &&
+             (_parseContext.extensionTurnedOn(E_GL_ARB_gpu_shader_int64) ||
+              _parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
+              _parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_int64))))
             return keyword;
         return identifierOrType();
 
@@ -1108,10 +1086,10 @@ int TScanContext::tokenizeIdentifier()
     case U8VEC3:
     case U8VEC4:
         afterType = true;
-        if (parseContext.symbolTable.atBuiltInLevel() ||
-            ((parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
-              parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_int8)) &&
-              parseContext.profile != EEsProfile && parseContext.version >= 450))
+        if (_parseContext.symbolTable.atBuiltInLevel() ||
+            ((_parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
+              _parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_int8)) &&
+              _parseContext.profile != EEsProfile && _parseContext.version >= 450))
             return keyword;
         return identifierOrType();
 
@@ -1124,14 +1102,14 @@ int TScanContext::tokenizeIdentifier()
     case U16VEC3:
     case U16VEC4:
         afterType = true;
-        if (parseContext.symbolTable.atBuiltInLevel() ||
-            (parseContext.profile != EEsProfile && parseContext.version >= 450 &&
+        if (_parseContext.symbolTable.atBuiltInLevel() ||
+            (_parseContext.profile != EEsProfile && _parseContext.version >= 450 &&
              (
 #ifdef AMD_EXTENSIONS
-              parseContext.extensionTurnedOn(E_GL_AMD_gpu_shader_int16) ||
+              _parseContext.extensionTurnedOn(E_GL_AMD_gpu_shader_int16) ||
 #endif
-              parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
-              parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_int16))))
+              _parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
+              _parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_int16))))
             return keyword;
         return identifierOrType();
     case INT32_T:
@@ -1143,10 +1121,10 @@ int TScanContext::tokenizeIdentifier()
     case U32VEC3:
     case U32VEC4:
         afterType = true;
-        if (parseContext.symbolTable.atBuiltInLevel() ||
-           ((parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
-             parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_int32)) &&
-             parseContext.profile != EEsProfile && parseContext.version >= 450))
+        if (_parseContext.symbolTable.atBuiltInLevel() ||
+           ((_parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
+             _parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_int32)) &&
+             _parseContext.profile != EEsProfile && _parseContext.version >= 450))
             return keyword;
         return identifierOrType();
     case FLOAT32_T:
@@ -1166,10 +1144,10 @@ int TScanContext::tokenizeIdentifier()
     case F32MAT4X3:
     case F32MAT4X4:
         afterType = true;
-        if (parseContext.symbolTable.atBuiltInLevel() ||
-            ((parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
-              parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_float32)) &&
-              parseContext.profile != EEsProfile && parseContext.version >= 450))
+        if (_parseContext.symbolTable.atBuiltInLevel() ||
+            ((_parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
+              _parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_float32)) &&
+              _parseContext.profile != EEsProfile && _parseContext.version >= 450))
             return keyword;
         return identifierOrType();
 
@@ -1190,10 +1168,10 @@ int TScanContext::tokenizeIdentifier()
     case F64MAT4X3:
     case F64MAT4X4:
         afterType = true;
-        if (parseContext.symbolTable.atBuiltInLevel() ||
-            ((parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
-              parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_float64)) &&
-              parseContext.profile != EEsProfile && parseContext.version >= 450))
+        if (_parseContext.symbolTable.atBuiltInLevel() ||
+            ((_parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
+              _parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_float64)) &&
+              _parseContext.profile != EEsProfile && _parseContext.version >= 450))
             return keyword;
         return identifierOrType();
 
@@ -1214,14 +1192,14 @@ int TScanContext::tokenizeIdentifier()
     case F16MAT4X3:
     case F16MAT4X4:
         afterType = true;
-        if (parseContext.symbolTable.atBuiltInLevel() ||
-            (parseContext.profile != EEsProfile && parseContext.version >= 450 &&
+        if (_parseContext.symbolTable.atBuiltInLevel() ||
+            (_parseContext.profile != EEsProfile && _parseContext.version >= 450 &&
              (
 #ifdef AMD_EXTENSIONS
-              parseContext.extensionTurnedOn(E_GL_AMD_gpu_shader_half_float) ||
+              _parseContext.extensionTurnedOn(E_GL_AMD_gpu_shader_half_float) ||
 #endif
-              parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
-              parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_float16))))
+              _parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types) ||
+              _parseContext.extensionTurnedOn(E_GL_KHX_shader_explicit_arithmetic_types_float16))))
             return keyword;
 
         return identifierOrType();
@@ -1231,10 +1209,10 @@ int TScanContext::tokenizeIdentifier()
     case ISAMPLERCUBEARRAY:
     case USAMPLERCUBEARRAY:
         afterType = true;
-        if ((parseContext.profile == EEsProfile && parseContext.version >= 320) ||
-            parseContext.extensionsTurnedOn(Num_AEP_texture_cube_map_array, AEP_texture_cube_map_array))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version >= 320) ||
+            _parseContext.extensionsTurnedOn(Num_AEP_texture_cube_map_array, AEP_texture_cube_map_array))
             return keyword;
-        if (parseContext.profile == EEsProfile || (parseContext.version < 400 && ! parseContext.extensionTurnedOn(E_GL_ARB_texture_cube_map_array)))
+        if (_parseContext.profile == EEsProfile || (_parseContext.version < 400 && ! _parseContext.extensionTurnedOn(E_GL_ARB_texture_cube_map_array)))
             reservedWord();
         return keyword;
 
@@ -1271,16 +1249,16 @@ int TScanContext::tokenizeIdentifier()
 
     case SAMPLERBUFFER:
         afterType = true;
-        if ((parseContext.profile == EEsProfile && parseContext.version >= 320) ||
-            parseContext.extensionsTurnedOn(Num_AEP_texture_buffer, AEP_texture_buffer))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version >= 320) ||
+            _parseContext.extensionsTurnedOn(Num_AEP_texture_buffer, AEP_texture_buffer))
             return keyword;
         return es30ReservedFromGLSL(130);
 
     case ISAMPLERBUFFER:
     case USAMPLERBUFFER:
         afterType = true;
-        if ((parseContext.profile == EEsProfile && parseContext.version >= 320) ||
-            parseContext.extensionsTurnedOn(Num_AEP_texture_buffer, AEP_texture_buffer))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version >= 320) ||
+            _parseContext.extensionsTurnedOn(Num_AEP_texture_buffer, AEP_texture_buffer))
             return keyword;
         return es30ReservedFromGLSL(140);
 
@@ -1288,7 +1266,7 @@ int TScanContext::tokenizeIdentifier()
     case ISAMPLER2DMS:
     case USAMPLER2DMS:
         afterType = true;
-        if (parseContext.profile == EEsProfile && parseContext.version >= 310)
+        if (_parseContext.profile == EEsProfile && _parseContext.version >= 310)
             return keyword;
         return es30ReservedFromGLSL(150);
 
@@ -1296,30 +1274,30 @@ int TScanContext::tokenizeIdentifier()
     case ISAMPLER2DMSARRAY:
     case USAMPLER2DMSARRAY:
         afterType = true;
-        if ((parseContext.profile == EEsProfile && parseContext.version >= 320) ||
-            parseContext.extensionsTurnedOn(1, &E_GL_OES_texture_storage_multisample_2d_array))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version >= 320) ||
+            _parseContext.extensionsTurnedOn(1, &E_GL_OES_texture_storage_multisample_2d_array))
             return keyword;
         return es30ReservedFromGLSL(150);
 
     case SAMPLER1D:
     case SAMPLER1DSHADOW:
         afterType = true;
-        if (parseContext.profile == EEsProfile)
+        if (_parseContext.profile == EEsProfile)
             reservedWord();
         return keyword;
 
     case SAMPLER3D:
         afterType = true;
-        if (parseContext.profile == EEsProfile && parseContext.version < 300) {
-            if (!parseContext.extensionTurnedOn(E_GL_OES_texture_3D))
+        if (_parseContext.profile == EEsProfile && _parseContext.version < 300) {
+            if (!_parseContext.extensionTurnedOn(E_GL_OES_texture_3D))
                 reservedWord();
         }
         return keyword;
 
     case SAMPLER2DSHADOW:
         afterType = true;
-        if (parseContext.profile == EEsProfile && parseContext.version < 300) {
-            if (!parseContext.extensionTurnedOn(E_GL_EXT_shadow_samplers))
+        if (_parseContext.profile == EEsProfile && _parseContext.version < 300) {
+            if (!_parseContext.extensionTurnedOn(E_GL_EXT_shadow_samplers))
                 reservedWord();
         }
         return keyword;
@@ -1327,11 +1305,11 @@ int TScanContext::tokenizeIdentifier()
     case SAMPLER2DRECT:
     case SAMPLER2DRECTSHADOW:
         afterType = true;
-        if (parseContext.profile == EEsProfile)
+        if (_parseContext.profile == EEsProfile)
             reservedWord();
-        else if (parseContext.version < 140 && ! parseContext.symbolTable.atBuiltInLevel() && ! parseContext.extensionTurnedOn(E_GL_ARB_texture_rectangle)) {
-            if (parseContext.relaxedErrors())
-                parseContext.requireExtensions(loc, 1, &E_GL_ARB_texture_rectangle, "texture-rectangle sampler keyword");
+        else if (_parseContext.version < 140 && ! _parseContext.symbolTable.atBuiltInLevel() && ! _parseContext.extensionTurnedOn(E_GL_ARB_texture_rectangle)) {
+            if (_parseContext.relaxedErrors())
+                _parseContext.requireExtensions(loc, 1, &E_GL_ARB_texture_rectangle, "texture-rectangle sampler keyword");
             else
                 reservedWord();
         }
@@ -1339,18 +1317,18 @@ int TScanContext::tokenizeIdentifier()
 
     case SAMPLER1DARRAY:
         afterType = true;
-        if (parseContext.profile == EEsProfile && parseContext.version == 300)
+        if (_parseContext.profile == EEsProfile && _parseContext.version == 300)
             reservedWord();
-        else if ((parseContext.profile == EEsProfile && parseContext.version < 300) ||
-                 (parseContext.profile != EEsProfile && parseContext.version < 130))
+        else if ((_parseContext.profile == EEsProfile && _parseContext.version < 300) ||
+                 (_parseContext.profile != EEsProfile && _parseContext.version < 130))
             return identifierOrType();
         return keyword;
 
     case SAMPLEREXTERNALOES:
         afterType = true;
-        if (parseContext.symbolTable.atBuiltInLevel() ||
-            parseContext.extensionTurnedOn(E_GL_OES_EGL_image_external) ||
-            parseContext.extensionTurnedOn(E_GL_OES_EGL_image_external_essl3))
+        if (_parseContext.symbolTable.atBuiltInLevel() ||
+            _parseContext.extensionTurnedOn(E_GL_OES_EGL_image_external) ||
+            _parseContext.extensionTurnedOn(E_GL_OES_EGL_image_external_essl3))
             return keyword;
         return identifierOrType();
 
@@ -1389,7 +1367,7 @@ int TScanContext::tokenizeIdentifier()
     case TEXTURE1DARRAY:
     case SAMPLER:
     case SAMPLERSHADOW:
-        if (parseContext.spvVersion.vulkan > 0)
+        if (_parseContext.spvVersion.vulkan > 0)
             return keyword;
         else
             return identifierOrType();
@@ -1400,7 +1378,7 @@ int TScanContext::tokenizeIdentifier()
     case ISUBPASSINPUTMS:
     case USUBPASSINPUT:
     case USUBPASSINPUTMS:
-        if (parseContext.spvVersion.vulkan > 0)
+        if (_parseContext.spvVersion.vulkan > 0)
             return keyword;
         else
             return identifierOrType();
@@ -1452,83 +1430,83 @@ int TScanContext::tokenizeIdentifier()
     case F16SUBPASSINPUT:
     case F16SUBPASSINPUTMS:
         afterType = true;
-        if (parseContext.symbolTable.atBuiltInLevel() ||
-            (parseContext.extensionTurnedOn(E_GL_AMD_gpu_shader_half_float_fetch) &&
-             parseContext.profile != EEsProfile && parseContext.version >= 450))
+        if (_parseContext.symbolTable.atBuiltInLevel() ||
+            (_parseContext.extensionTurnedOn(E_GL_AMD_gpu_shader_half_float_fetch) &&
+             _parseContext.profile != EEsProfile && _parseContext.version >= 450))
             return keyword;
         return identifierOrType();
 #endif
 
     case NOPERSPECTIVE:
 #ifdef NV_EXTENSIONS
-        if (parseContext.profile == EEsProfile && parseContext.version >= 300 &&
-            parseContext.extensionTurnedOn(E_GL_NV_shader_noperspective_interpolation))
+        if (_parseContext.profile == EEsProfile && _parseContext.version >= 300 &&
+            _parseContext.extensionTurnedOn(E_GL_NV_shader_noperspective_interpolation))
             return keyword;
 #endif
         return es30ReservedFromGLSL(130);
 
     case SMOOTH:
-        if ((parseContext.profile == EEsProfile && parseContext.version < 300) ||
-            (parseContext.profile != EEsProfile && parseContext.version < 130))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version < 300) ||
+            (_parseContext.profile != EEsProfile && _parseContext.version < 130))
             return identifierOrType();
         return keyword;
 
 #ifdef AMD_EXTENSIONS
     case __EXPLICITINTERPAMD:
-        if (parseContext.profile != EEsProfile && parseContext.version >= 450 &&
-            parseContext.extensionTurnedOn(E_GL_AMD_shader_explicit_vertex_parameter))
+        if (_parseContext.profile != EEsProfile && _parseContext.version >= 450 &&
+            _parseContext.extensionTurnedOn(E_GL_AMD_shader_explicit_vertex_parameter))
             return keyword;
         return identifierOrType();
 #endif
 
     case FLAT:
-        if (parseContext.profile == EEsProfile && parseContext.version < 300)
+        if (_parseContext.profile == EEsProfile && _parseContext.version < 300)
             reservedWord();
-        else if (parseContext.profile != EEsProfile && parseContext.version < 130)
+        else if (_parseContext.profile != EEsProfile && _parseContext.version < 130)
             return identifierOrType();
         return keyword;
 
     case CENTROID:
-        if (parseContext.version < 120)
+        if (_parseContext.version < 120)
             return identifierOrType();
         return keyword;
 
     case PRECISE:
-        if ((parseContext.profile == EEsProfile &&
-             (parseContext.version >= 320 || parseContext.extensionsTurnedOn(Num_AEP_gpu_shader5, AEP_gpu_shader5))) ||
-            (parseContext.profile != EEsProfile && parseContext.version >= 400))
+        if ((_parseContext.profile == EEsProfile &&
+             (_parseContext.version >= 320 || _parseContext.extensionsTurnedOn(Num_AEP_gpu_shader5, AEP_gpu_shader5))) ||
+            (_parseContext.profile != EEsProfile && _parseContext.version >= 400))
             return keyword;
-        if (parseContext.profile == EEsProfile && parseContext.version == 310) {
+        if (_parseContext.profile == EEsProfile && _parseContext.version == 310) {
             reservedWord();
             return keyword;
         }
         return identifierOrType();
 
     case INVARIANT:
-        if (parseContext.profile != EEsProfile && parseContext.version < 120)
+        if (_parseContext.profile != EEsProfile && _parseContext.version < 120)
             return identifierOrType();
         return keyword;
 
     case PACKED:
-        if ((parseContext.profile == EEsProfile && parseContext.version < 300) ||
-            (parseContext.profile != EEsProfile && parseContext.version < 330))
+        if ((_parseContext.profile == EEsProfile && _parseContext.version < 300) ||
+            (_parseContext.profile != EEsProfile && _parseContext.version < 330))
             return reservedWord();
         return identifierOrType();
 
     case RESOURCE:
     {
-        bool reserved = (parseContext.profile == EEsProfile && parseContext.version >= 300) ||
-                        (parseContext.profile != EEsProfile && parseContext.version >= 420);
+        bool reserved = (_parseContext.profile == EEsProfile && _parseContext.version >= 300) ||
+                        (_parseContext.profile != EEsProfile && _parseContext.version >= 420);
         return identifierOrReserved(reserved);
     }
     case SUPERP:
     {
-        bool reserved = parseContext.profile == EEsProfile || parseContext.version >= 130;
+        bool reserved = _parseContext.profile == EEsProfile || _parseContext.version >= 130;
         return identifierOrReserved(reserved);
     }
 
     default:
-        parseContext.infoSink.info.message(EPrefixInternalError, "Unknown glslang keyword", loc);
+        _parseContext.infoSink.info.message(EPrefixInternalError, "Unknown glslang keyword", loc);
         return 0;
     }
 }
@@ -1539,7 +1517,7 @@ int TScanContext::identifierOrType()
     if (field)
         return IDENTIFIER;
 
-    parserToken->sType.lex.symbol = parseContext.symbolTable.find(*parserToken->sType.lex.string);
+    parserToken->sType.lex.symbol = _parseContext.symbolTable.find(*parserToken->sType.lex.string);
     if ((afterType == false && afterStruct == false) && parserToken->sType.lex.symbol != nullptr) {
         if (const TVariable* variable = parserToken->sType.lex.symbol->getAsVariable()) {
             if (variable->isUserType()) {
@@ -1558,8 +1536,8 @@ int TScanContext::identifierOrType()
 // extension support before the extension is enabled.
 int TScanContext::reservedWord()
 {
-    if (! parseContext.symbolTable.atBuiltInLevel())
-        parseContext.error(loc, "Reserved word.", tokenText, "", "");
+    if (! _parseContext.symbolTable.atBuiltInLevel())
+        _parseContext.error(loc, "Reserved word.", tokenText, "", "");
 
     return 0;
 }
@@ -1572,8 +1550,8 @@ int TScanContext::identifierOrReserved(bool reserved)
         return 0;
     }
 
-    if (parseContext.forwardCompatible)
-        parseContext.warn(loc, "using future reserved keyword", tokenText, "");
+    if (_parseContext.forwardCompatible)
+        _parseContext.warn(loc, "using future reserved keyword", tokenText, "");
 
     return identifierOrType();
 }
@@ -1582,16 +1560,16 @@ int TScanContext::identifierOrReserved(bool reserved)
 // but then got reserved by ES 3.0.
 int TScanContext::es30ReservedFromGLSL(int version)
 {
-    if (parseContext.symbolTable.atBuiltInLevel())
+    if (_parseContext.symbolTable.atBuiltInLevel())
         return keyword;
 
-    if ((parseContext.profile == EEsProfile && parseContext.version < 300) ||
-        (parseContext.profile != EEsProfile && parseContext.version < version)) {
-            if (parseContext.forwardCompatible)
-                parseContext.warn(loc, "future reserved word in ES 300 and keyword in GLSL", tokenText, "");
+    if ((_parseContext.profile == EEsProfile && _parseContext.version < 300) ||
+        (_parseContext.profile != EEsProfile && _parseContext.version < version)) {
+            if (_parseContext.forwardCompatible)
+                _parseContext.warn(loc, "future reserved word in ES 300 and keyword in GLSL", tokenText, "");
 
             return identifierOrType();
-    } else if (parseContext.profile == EEsProfile && parseContext.version >= 300)
+    } else if (_parseContext.profile == EEsProfile && _parseContext.version >= 300)
         reservedWord();
 
     return keyword;
@@ -1601,10 +1579,10 @@ int TScanContext::es30ReservedFromGLSL(int version)
 // showed up, both in an es version and a non-ES version.
 int TScanContext::nonreservedKeyword(int esVersion, int nonEsVersion)
 {
-    if ((parseContext.profile == EEsProfile && parseContext.version < esVersion) ||
-        (parseContext.profile != EEsProfile && parseContext.version < nonEsVersion)) {
-        if (parseContext.forwardCompatible)
-            parseContext.warn(loc, "using future keyword", tokenText, "");
+    if ((_parseContext.profile == EEsProfile && _parseContext.version < esVersion) ||
+        (_parseContext.profile != EEsProfile && _parseContext.version < nonEsVersion)) {
+        if (_parseContext.forwardCompatible)
+            _parseContext.warn(loc, "using future keyword", tokenText, "");
 
         return identifierOrType();
     }
@@ -1614,11 +1592,11 @@ int TScanContext::nonreservedKeyword(int esVersion, int nonEsVersion)
 
 int TScanContext::precisionKeyword()
 {
-    if (parseContext.profile == EEsProfile || parseContext.version >= 130)
+    if (_parseContext.profile == EEsProfile || _parseContext.version >= 130)
         return keyword;
 
-    if (parseContext.forwardCompatible)
-        parseContext.warn(loc, "using ES precision qualifier keyword", tokenText, "");
+    if (_parseContext.forwardCompatible)
+        _parseContext.warn(loc, "using ES precision qualifier keyword", tokenText, "");
 
     return identifierOrType();
 }
@@ -1627,11 +1605,11 @@ int TScanContext::matNxM()
 {
     afterType = true;
 
-    if (parseContext.version > 110)
+    if (_parseContext.version > 110)
         return keyword;
 
-    if (parseContext.forwardCompatible)
-        parseContext.warn(loc, "using future non-square matrix type keyword", tokenText, "");
+    if (_parseContext.forwardCompatible)
+        _parseContext.warn(loc, "using future non-square matrix type keyword", tokenText, "");
 
     return identifierOrType();
 }
@@ -1640,56 +1618,56 @@ int TScanContext::dMat()
 {
     afterType = true;
 
-    if (parseContext.profile == EEsProfile && parseContext.version >= 300) {
+    if (_parseContext.profile == EEsProfile && _parseContext.version >= 300) {
         reservedWord();
 
         return keyword;
     }
 
-    if (parseContext.profile != EEsProfile && parseContext.version >= 400)
+    if (_parseContext.profile != EEsProfile && _parseContext.version >= 400)
         return keyword;
 
-    if (parseContext.forwardCompatible)
-        parseContext.warn(loc, "using future type keyword", tokenText, "");
+    if (_parseContext.forwardCompatible)
+        _parseContext.warn(loc, "using future type keyword", tokenText, "");
 
     return identifierOrType();
 }
 
 int TScanContext::firstGenerationImage(bool inEs310)
 {
-    if (parseContext.symbolTable.atBuiltInLevel() ||
-        (parseContext.profile != EEsProfile && (parseContext.version >= 420 ||
-         parseContext.extensionTurnedOn(E_GL_ARB_shader_image_load_store))) ||
-        (inEs310 && parseContext.profile == EEsProfile && parseContext.version >= 310))
+    if (_parseContext.symbolTable.atBuiltInLevel() ||
+        (_parseContext.profile != EEsProfile && (_parseContext.version >= 420 ||
+         _parseContext.extensionTurnedOn(E_GL_ARB_shader_image_load_store))) ||
+        (inEs310 && _parseContext.profile == EEsProfile && _parseContext.version >= 310))
         return keyword;
 
-    if ((parseContext.profile == EEsProfile && parseContext.version >= 300) ||
-        (parseContext.profile != EEsProfile && parseContext.version >= 130)) {
+    if ((_parseContext.profile == EEsProfile && _parseContext.version >= 300) ||
+        (_parseContext.profile != EEsProfile && _parseContext.version >= 130)) {
         reservedWord();
 
         return keyword;
     }
 
-    if (parseContext.forwardCompatible)
-        parseContext.warn(loc, "using future type keyword", tokenText, "");
+    if (_parseContext.forwardCompatible)
+        _parseContext.warn(loc, "using future type keyword", tokenText, "");
 
     return identifierOrType();
 }
 
 int TScanContext::secondGenerationImage()
 {
-    if (parseContext.profile == EEsProfile && parseContext.version >= 310) {
+    if (_parseContext.profile == EEsProfile && _parseContext.version >= 310) {
         reservedWord();
         return keyword;
     }
 
-    if (parseContext.symbolTable.atBuiltInLevel() ||
-        (parseContext.profile != EEsProfile &&
-         (parseContext.version >= 420 || parseContext.extensionTurnedOn(E_GL_ARB_shader_image_load_store))))
+    if (_parseContext.symbolTable.atBuiltInLevel() ||
+        (_parseContext.profile != EEsProfile &&
+         (_parseContext.version >= 420 || _parseContext.extensionTurnedOn(E_GL_ARB_shader_image_load_store))))
         return keyword;
 
-    if (parseContext.forwardCompatible)
-        parseContext.warn(loc, "using future type keyword", tokenText, "");
+    if (_parseContext.forwardCompatible)
+        _parseContext.warn(loc, "using future type keyword", tokenText, "");
 
     return identifierOrType();
 }
diff --git a/deps/glslang/glslang/glslang/MachineIndependent/ScanContext.h b/deps/glslang/glslang/glslang/MachineIndependent/ScanContext.h
index 0cc7ea0a9e..39e7761a62 100755
--- a/deps/glslang/glslang/glslang/MachineIndependent/ScanContext.h
+++ b/deps/glslang/glslang/glslang/MachineIndependent/ScanContext.h
@@ -33,6 +33,9 @@
 // POSSIBILITY OF SUCH DAMAGE.
 //
 
+#ifndef _MACHINE_INDEPENDENT_SCAN_CONTEXT_H
+#define _MACHINE_INDEPENDENT_SCAN_CONTEXT_H
+
 //
 // This holds context specific to the GLSL scanner, which
 // sits between the preprocessor scanner and parser.
@@ -51,7 +54,7 @@ class TParserToken;
 class TScanContext {
 public:
     explicit TScanContext(TParseContextBase& pc) :
-        parseContext(pc),
+        _parseContext(pc),
         afterType(false), afterStruct(false),
         field(false) { }
     virtual ~TScanContext() { }
@@ -77,7 +80,7 @@ protected:
     int firstGenerationImage(bool inEs310);
     int secondGenerationImage();
 
-    TParseContextBase& parseContext;
+    TParseContextBase& _parseContext;
     bool afterType;           // true if we've recognized a type, so can only be looking for an identifier
     bool afterStruct;         // true if we've recognized the STRUCT keyword, so can only be looking for an identifier
     bool field;               // true if we're on a field, right after a '.'
@@ -90,3 +93,5 @@ protected:
 };
 
 } // end namespace glslang
+
+#endif
diff --git a/deps/glslang/glslang/glslang/MachineIndependent/ShaderLang.cpp b/deps/glslang/glslang/glslang/MachineIndependent/ShaderLang.cpp
index 4f39f3453e..7a3061821d 100644
--- a/deps/glslang/glslang/glslang/MachineIndependent/ShaderLang.cpp
+++ b/deps/glslang/glslang/glslang/MachineIndependent/ShaderLang.cpp
@@ -233,15 +233,15 @@ bool InitializeSymbolTable(const TString& builtIns, int version, EProfile profil
 
     intermediate.setSource(source);
 
-    std::unique_ptr<TParseContextBase> parseContext(CreateParseContext(symbolTable, intermediate, version, profile, source,
+    std::unique_ptr<TParseContextBase> _parseContext(CreateParseContext(symbolTable, intermediate, version, profile, source,
                                                                        language, infoSink, spvVersion, true, EShMsgDefault,
                                                                        true));
 
     TShader::ForbidIncluder includer;
-    TPpContext ppContext(*parseContext, "", includer);
-    TScanContext scanContext(*parseContext);
-    parseContext->setScanContext(&scanContext);
-    parseContext->setPpContext(&ppContext);
+    TPpContext ppContext(*_parseContext, "", includer);
+    TScanContext scanContext(*_parseContext);
+    _parseContext->setScanContext(&scanContext);
+    _parseContext->setPpContext(&ppContext);
 
     //
     // Push the symbol table to give it an initial scope.  This
@@ -260,7 +260,7 @@ bool InitializeSymbolTable(const TString& builtIns, int version, EProfile profil
         return true;
 
     TInputScanner input(1, builtInShaders, builtInLengths);
-    if (! parseContext->parseShaderStrings(ppContext, input) != 0) {
+    if (! _parseContext->parseShaderStrings(ppContext, input) != 0) {
         infoSink.info.message(EPrefixInternalError, "Unable to parse built-ins");
         printf("Unable to parse built-ins\n%s\n", infoSink.info.c_str());
         printf("%s\n", builtInShaders[0]);
@@ -696,7 +696,7 @@ void RecordProcesses(TIntermediate& intermediate, EShMessages messages, const st
 // This is the common setup and cleanup code for PreprocessDeferred and
 // CompileDeferred.
 // It takes any callable with a signature of
-//  bool (TParseContextBase& parseContext, TPpContext& ppContext,
+//  bool (TParseContextBase& _parseContext, TPpContext& ppContext,
 //                  TInputScanner& input, bool versionWillBeError,
 //                  TSymbolTable& , TIntermediate& ,
 //                  EShOptimizationLevel , EShMessages );
@@ -849,31 +849,31 @@ bool ProcessDeferred(
     // Now we can process the full shader under proper symbols and rules.
     //
 
-    std::unique_ptr<TParseContextBase> parseContext(CreateParseContext(*symbolTable, intermediate, version, profile, source,
+    std::unique_ptr<TParseContextBase> _parseContext(CreateParseContext(*symbolTable, intermediate, version, profile, source,
                                                     stage, compiler->infoSink,
                                                     spvVersion, forwardCompatible, messages, false, sourceEntryPointName));
-    TPpContext ppContext(*parseContext, names[numPre] ? names[numPre] : "", includer);
+    TPpContext ppContext(*_parseContext, names[numPre] ? names[numPre] : "", includer);
 
     // only GLSL (bison triggered, really) needs an externally set scan context
-    glslang::TScanContext scanContext(*parseContext);
+    glslang::TScanContext scanContext(*_parseContext);
     if (source == EShSourceGlsl)
-        parseContext->setScanContext(&scanContext);
+        _parseContext->setScanContext(&scanContext);
 
-    parseContext->setPpContext(&ppContext);
-    parseContext->setLimits(*resources);
+    _parseContext->setPpContext(&ppContext);
+    _parseContext->setLimits(*resources);
     if (! goodVersion)
-        parseContext->addError();
+        _parseContext->addError();
     if (warnVersionNotFirst) {
         TSourceLoc loc;
         loc.init();
-        parseContext->warn(loc, "Illegal to have non-comment, non-whitespace tokens before #version", "#version", "");
+        _parseContext->warn(loc, "Illegal to have non-comment, non-whitespace tokens before #version", "#version", "");
     }
 
-    parseContext->initializeExtensionBehavior();
+    _parseContext->initializeExtensionBehavior();
 
     // Fill in the strings as outlined above.
     std::string preamble;
-    parseContext->getPreamble(preamble);
+    _parseContext->getPreamble(preamble);
     strings[0] = preamble.c_str();
     lengths[0] = strlen(strings[0]);
     names[0] = nullptr;
@@ -892,7 +892,7 @@ bool ProcessDeferred(
     // Push a new symbol allocation scope that will get used for the shader's globals.
     symbolTable->push();
 
-    bool success = processingContext(*parseContext, ppContext, fullInput,
+    bool success = processingContext(*_parseContext, ppContext, fullInput,
                                      versionWillBeError, *symbolTable,
                                      intermediate, optLevel, messages);
     return success;
@@ -967,7 +967,7 @@ private:
 // It places the result in the "string" argument to its constructor.
 struct DoPreprocessing {
     explicit DoPreprocessing(std::string* string): outputString(string) {}
-    bool operator()(TParseContextBase& parseContext, TPpContext& ppContext,
+    bool operator()(TParseContextBase& _parseContext, TPpContext& ppContext,
                     TInputScanner& input, bool versionWillBeError,
                     TSymbolTable&, TIntermediate&,
                     EShOptimizationLevel, EShMessages)
@@ -977,14 +977,14 @@ struct DoPreprocessing {
         static const std::string noSpaceBeforeTokens = ",";
         glslang::TPpToken ppToken;
 
-        parseContext.setScanner(&input);
+        _parseContext.setScanner(&input);
         ppContext.setInput(input, versionWillBeError);
 
         std::string outputBuffer;
         SourceLineSynchronizer lineSync(
             std::bind(&TInputScanner::getLastValidSourceIndex, &input), &outputBuffer);
 
-        parseContext.setExtensionCallback([&lineSync, &outputBuffer](
+        _parseContext.setExtensionCallback([&lineSync, &outputBuffer](
             int line, const char* extension, const char* behavior) {
                 lineSync.syncToLine(line);
                 outputBuffer += "#extension ";
@@ -993,7 +993,7 @@ struct DoPreprocessing {
                 outputBuffer += behavior;
         });
 
-        parseContext.setLineCallback([&lineSync, &outputBuffer, &parseContext](
+        _parseContext.setLineCallback([&lineSync, &outputBuffer, &_parseContext](
             int curLineNum, int newLineNum, bool hasSource, int sourceNum, const char* sourceName) {
             // SourceNum is the number of the source-string that is being parsed.
             lineSync.syncToLine(curLineNum);
@@ -1009,7 +1009,7 @@ struct DoPreprocessing {
                     outputBuffer += std::to_string(sourceNum);
                 }
             }
-            if (parseContext.lineDirectiveShouldSetNextLine()) {
+            if (_parseContext.lineDirectiveShouldSetNextLine()) {
                 // newLineNum is the new line number for the line following the #line
                 // directive. So the new line number for the current line is
                 newLineNum -= 1;
@@ -1019,7 +1019,7 @@ struct DoPreprocessing {
             lineSync.setLineNum(newLineNum + 1);
         });
 
-        parseContext.setVersionCallback(
+        _parseContext.setVersionCallback(
             [&lineSync, &outputBuffer](int line, int version, const char* str) {
                 lineSync.syncToLine(line);
                 outputBuffer += "#version ";
@@ -1030,7 +1030,7 @@ struct DoPreprocessing {
                 }
             });
 
-        parseContext.setPragmaCallback([&lineSync, &outputBuffer](
+        _parseContext.setPragmaCallback([&lineSync, &outputBuffer](
             int line, const glslang::TVector<glslang::TString>& ops) {
                 lineSync.syncToLine(line);
                 outputBuffer += "#pragma ";
@@ -1039,7 +1039,7 @@ struct DoPreprocessing {
                 }
         });
 
-        parseContext.setErrorCallback([&lineSync, &outputBuffer](
+        _parseContext.setErrorCallback([&lineSync, &outputBuffer](
             int line, const char* errorMessage) {
                 lineSync.syncToLine(line);
                 outputBuffer += "#error ";
@@ -1078,10 +1078,10 @@ struct DoPreprocessing {
         *outputString = std::move(outputBuffer);
 
         bool success = true;
-        if (parseContext.getNumErrors() > 0) {
+        if (_parseContext.getNumErrors() > 0) {
             success = false;
-            parseContext.infoSink.info.prefix(EPrefixError);
-            parseContext.infoSink.info << parseContext.getNumErrors() << " compilation errors.  No code generated.\n\n";
+            _parseContext.infoSink.info.prefix(EPrefixError);
+            _parseContext.infoSink.info << _parseContext.getNumErrors() << " compilation errors.  No code generated.\n\n";
         }
         return success;
     }
@@ -1091,28 +1091,28 @@ struct DoPreprocessing {
 // DoFullParse is a valid ProcessingConext template argument for fully
 // parsing the shader.  It populates the "intermediate" with the AST.
 struct DoFullParse{
-  bool operator()(TParseContextBase& parseContext, TPpContext& ppContext,
+  bool operator()(TParseContextBase& _parseContext, TPpContext& ppContext,
                   TInputScanner& fullInput, bool versionWillBeError,
                   TSymbolTable&, TIntermediate& intermediate,
                   EShOptimizationLevel optLevel, EShMessages messages)
     {
         bool success = true;
         // Parse the full shader.
-        if (! parseContext.parseShaderStrings(ppContext, fullInput, versionWillBeError))
+        if (! _parseContext.parseShaderStrings(ppContext, fullInput, versionWillBeError))
             success = false;
 
         if (success && intermediate.getTreeRoot()) {
             if (optLevel == EShOptNoGeneration)
-                parseContext.infoSink.info.message(EPrefixNone, "No errors.  No code generation or linking was requested.");
+                _parseContext.infoSink.info.message(EPrefixNone, "No errors.  No code generation or linking was requested.");
             else
-                success = intermediate.postProcess(intermediate.getTreeRoot(), parseContext.getLanguage());
+                success = intermediate.postProcess(intermediate.getTreeRoot(), _parseContext.getLanguage());
         } else if (! success) {
-            parseContext.infoSink.info.prefix(EPrefixError);
-            parseContext.infoSink.info << parseContext.getNumErrors() << " compilation errors.  No code generated.\n\n";
+            _parseContext.infoSink.info.prefix(EPrefixError);
+            _parseContext.infoSink.info << _parseContext.getNumErrors() << " compilation errors.  No code generated.\n\n";
         }
 
         if (messages & EShMsgAST)
-            intermediate.output(parseContext.infoSink, true);
+            intermediate.output(_parseContext.infoSink, true);
 
         return success;
     }
diff --git a/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/Pp.cpp b/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/Pp.cpp
index 8048fa513d..6a2ab91904 100644
--- a/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/Pp.cpp
+++ b/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/Pp.cpp
@@ -99,12 +99,12 @@ int TPpContext::CPPdefine(TPpToken* ppToken)
     // get the macro name
     int token = scanToken(ppToken);
     if (token != PpAtomIdentifier) {
-        parseContext.ppError(ppToken->loc, "must be followed by macro name", "#define", "");
+        _parseContext.ppError(ppToken->loc, "must be followed by macro name", "#define", "");
         return token;
     }
     if (ppToken->loc.string >= 0) {
         // We are in user code; check for reserved name use:
-        parseContext.reservedPpErrorCheck(ppToken->loc, ppToken->name, "#define");
+        _parseContext.reservedPpErrorCheck(ppToken->loc, ppToken->name, "#define");
     }
 
     // save the macro name
@@ -119,7 +119,7 @@ int TPpContext::CPPdefine(TPpToken* ppToken)
             if (mac.args.size() == 0 && token == ')')
                 break;
             if (token != PpAtomIdentifier) {
-                parseContext.ppError(ppToken->loc, "bad argument", "#define", "");
+                _parseContext.ppError(ppToken->loc, "bad argument", "#define", "");
 
                 return token;
             }
@@ -130,7 +130,7 @@ int TPpContext::CPPdefine(TPpToken* ppToken)
             bool duplicate = false;
             for (size_t a = 0; a < mac.args.size(); ++a) {
                 if (mac.args[a] == argAtom) {
-                    parseContext.ppError(ppToken->loc, "duplicate macro parameter", "#define", "");
+                    _parseContext.ppError(ppToken->loc, "duplicate macro parameter", "#define", "");
                     duplicate = true;
                     break;
                 }
@@ -140,7 +140,7 @@ int TPpContext::CPPdefine(TPpToken* ppToken)
             token = scanToken(ppToken);
         } while (token == ',');
         if (token != ')') {
-            parseContext.ppError(ppToken->loc, "missing parenthesis", "#define", "");
+            _parseContext.ppError(ppToken->loc, "missing parenthesis", "#define", "");
 
             return token;
         }
@@ -165,10 +165,10 @@ int TPpContext::CPPdefine(TPpToken* ppToken)
             // "Two replacement lists are identical if and only if the preprocessing tokens in both have the same number,
             // ordering, spelling, and white-space separation, where all white-space separations are considered identical."
             if (existing->args.size() != mac.args.size() || existing->emptyArgs != mac.emptyArgs)
-                parseContext.ppError(defineLoc, "Macro redefined; different number of arguments:", "#define", atomStrings.getString(defAtom));
+                _parseContext.ppError(defineLoc, "Macro redefined; different number of arguments:", "#define", atomStrings.getString(defAtom));
             else {
                 if (existing->args != mac.args)
-                    parseContext.ppError(defineLoc, "Macro redefined; different argument names:", "#define", atomStrings.getString(defAtom));
+                    _parseContext.ppError(defineLoc, "Macro redefined; different argument names:", "#define", atomStrings.getString(defAtom));
                 existing->body.reset();
                 mac.body.reset();
                 int newToken;
@@ -176,10 +176,10 @@ int TPpContext::CPPdefine(TPpToken* ppToken)
                     int oldToken;
                     TPpToken oldPpToken;
                     TPpToken newPpToken;
-                    oldToken = existing->body.getToken(parseContext, &oldPpToken);
-                    newToken = mac.body.getToken(parseContext, &newPpToken);
+                    oldToken = existing->body.getToken(_parseContext, &oldPpToken);
+                    newToken = mac.body.getToken(_parseContext, &newPpToken);
                     if (oldToken != newToken || oldPpToken != newPpToken) {
-                        parseContext.ppError(defineLoc, "Macro redefined; different substitutions:", "#define", atomStrings.getString(defAtom));
+                        _parseContext.ppError(defineLoc, "Macro redefined; different substitutions:", "#define", atomStrings.getString(defAtom));
                         break;
                     }
                 } while (newToken > 0);
@@ -197,19 +197,19 @@ int TPpContext::CPPundef(TPpToken* ppToken)
 {
     int token = scanToken(ppToken);
     if (token != PpAtomIdentifier) {
-        parseContext.ppError(ppToken->loc, "must be followed by macro name", "#undef", "");
+        _parseContext.ppError(ppToken->loc, "must be followed by macro name", "#undef", "");
 
         return token;
     }
 
-    parseContext.reservedPpErrorCheck(ppToken->loc, ppToken->name, "#undef");
+    _parseContext.reservedPpErrorCheck(ppToken->loc, ppToken->name, "#undef");
 
     MacroSymbol* macro = lookupMacroDef(atomStrings.getAtom(ppToken->name));
     if (macro != nullptr)
         macro->undef = 1;
     token = scanToken(ppToken);
     if (token != '\n')
-        parseContext.ppError(ppToken->loc, "can only be followed by a single macro name", "#undef", "");
+        _parseContext.ppError(ppToken->loc, "can only be followed by a single macro name", "#undef", "");
 
     return token;
 }
@@ -243,7 +243,7 @@ int TPpContext::CPPelse(int matchelse, TPpToken* ppToken)
         if (nextAtom == PpAtomIf || nextAtom == PpAtomIfdef || nextAtom == PpAtomIfndef) {
             depth++;
             if (ifdepth >= maxIfNesting || elsetracker >= maxIfNesting) {
-                parseContext.ppError(ppToken->loc, "maximum nesting depth exceeded", "#if/#ifdef/#ifndef", "");
+                _parseContext.ppError(ppToken->loc, "maximum nesting depth exceeded", "#if/#ifdef/#ifndef", "");
                 return EndOfInput;
             } else {
                 ifdepth++;
@@ -269,7 +269,7 @@ int TPpContext::CPPelse(int matchelse, TPpToken* ppToken)
                 break;
             } else if (nextAtom == PpAtomElif) {
                 if (elseSeen[elsetracker])
-                    parseContext.ppError(ppToken->loc, "#elif after #else", "#elif", "");
+                    _parseContext.ppError(ppToken->loc, "#elif after #else", "#elif", "");
                 /* we decrement ifdepth here, because CPPif will increment
                 * it and we really want to leave it alone */
                 if (ifdepth > 0) {
@@ -282,13 +282,13 @@ int TPpContext::CPPelse(int matchelse, TPpToken* ppToken)
             }
         } else if (nextAtom == PpAtomElse) {
             if (elseSeen[elsetracker])
-                parseContext.ppError(ppToken->loc, "#else after #else", "#else", "");
+                _parseContext.ppError(ppToken->loc, "#else after #else", "#else", "");
             else
                 elseSeen[elsetracker] = true;
             token = extraTokenCheck(nextAtom, ppToken, scanToken(ppToken));
         } else if (nextAtom == PpAtomElif) {
             if (elseSeen[elsetracker])
-                parseContext.ppError(ppToken->loc, "#elif after #else", "#elif", "");
+                _parseContext.ppError(ppToken->loc, "#elif after #else", "#elif", "");
         }
     }
 
@@ -315,10 +315,10 @@ int TPpContext::extraTokenCheck(int contextAtom, TPpToken* ppToken, int token)
         else
             label = "";
 
-        if (parseContext.relaxedErrors())
-            parseContext.ppWarn(ppToken->loc, message, label, "");
+        if (_parseContext.relaxedErrors())
+            _parseContext.ppWarn(ppToken->loc, message, label, "");
         else
-            parseContext.ppError(ppToken->loc, message, label, "");
+            _parseContext.ppError(ppToken->loc, message, label, "");
 
         while (token != '\n' && token != EndOfInput)
             token = scanToken(ppToken);
@@ -399,12 +399,12 @@ int TPpContext::eval(int token, int precedence, bool shortCircuit, int& res, boo
     TSourceLoc loc = ppToken->loc;  // because we sometimes read the newline before reporting the error
     if (token == PpAtomIdentifier) {
         if (strcmp("defined", ppToken->name) == 0) {
-            if (! parseContext.isReadingHLSL() && isMacroInput()) {
-                if (parseContext.relaxedErrors())
-                    parseContext.ppWarn(ppToken->loc, "nonportable when expanded from macros for preprocessor expression",
+            if (! _parseContext.isReadingHLSL() && isMacroInput()) {
+                if (_parseContext.relaxedErrors())
+                    _parseContext.ppWarn(ppToken->loc, "nonportable when expanded from macros for preprocessor expression",
                                                       "defined", "");
                 else
-                    parseContext.ppError(ppToken->loc, "cannot use in preprocessor expression when expanded from macros",
+                    _parseContext.ppError(ppToken->loc, "cannot use in preprocessor expression when expanded from macros",
                                                        "defined", "");
             }
             bool needclose = 0;
@@ -414,7 +414,7 @@ int TPpContext::eval(int token, int precedence, bool shortCircuit, int& res, boo
                 token = scanToken(ppToken);
             }
             if (token != PpAtomIdentifier) {
-                parseContext.ppError(loc, "incorrect directive, expected identifier", "preprocessor evaluation", "");
+                _parseContext.ppError(loc, "incorrect directive, expected identifier", "preprocessor evaluation", "");
                 err = true;
                 res = 0;
 
@@ -426,7 +426,7 @@ int TPpContext::eval(int token, int precedence, bool shortCircuit, int& res, boo
             token = scanToken(ppToken);
             if (needclose) {
                 if (token != ')') {
-                    parseContext.ppError(loc, "expected ')'", "preprocessor evaluation", "");
+                    _parseContext.ppError(loc, "expected ')'", "preprocessor evaluation", "");
                     err = true;
                     res = 0;
 
@@ -446,7 +446,7 @@ int TPpContext::eval(int token, int precedence, bool shortCircuit, int& res, boo
         token = eval(token, MIN_PRECEDENCE, shortCircuit, res, err, ppToken);
         if (! err) {
             if (token != ')') {
-                parseContext.ppError(loc, "expected ')'", "preprocessor evaluation", "");
+                _parseContext.ppError(loc, "expected ')'", "preprocessor evaluation", "");
                 err = true;
                 res = 0;
 
@@ -465,7 +465,7 @@ int TPpContext::eval(int token, int precedence, bool shortCircuit, int& res, boo
             token = eval(token, UNARY, shortCircuit, res, err, ppToken);
             res = unop[op].op(res);
         } else {
-            parseContext.ppError(loc, "bad expression", "preprocessor evaluation", "");
+            _parseContext.ppError(loc, "bad expression", "preprocessor evaluation", "");
             err = true;
             res = 0;
 
@@ -501,7 +501,7 @@ int TPpContext::eval(int token, int precedence, bool shortCircuit, int& res, boo
 
         if (binop[op].op == op_div || binop[op].op == op_mod) {
             if (res == 0) {
-                parseContext.ppError(loc, "division by 0", "preprocessor evaluation", "");
+                _parseContext.ppError(loc, "division by 0", "preprocessor evaluation", "");
                 res = 1;
             }
         }
@@ -517,19 +517,19 @@ int TPpContext::evalToToken(int token, bool shortCircuit, int& res, bool& err, T
     while (token == PpAtomIdentifier && strcmp("defined", ppToken->name) != 0) {
         int macroReturn = MacroExpand(ppToken, true, false);
         if (macroReturn == 0) {
-            parseContext.ppError(ppToken->loc, "can't evaluate expression", "preprocessor evaluation", "");
+            _parseContext.ppError(ppToken->loc, "can't evaluate expression", "preprocessor evaluation", "");
             err = true;
             res = 0;
             token = scanToken(ppToken);
             break;
         }
         if (macroReturn == -1) {
-            if (! shortCircuit && parseContext.profile == EEsProfile) {
+            if (! shortCircuit && _parseContext.profile == EEsProfile) {
                 const char* message = "undefined macro in expression not allowed in es profile";
-                if (parseContext.relaxedErrors())
-                    parseContext.ppWarn(ppToken->loc, message, "preprocessor evaluation", ppToken->name);
+                if (_parseContext.relaxedErrors())
+                    _parseContext.ppWarn(ppToken->loc, message, "preprocessor evaluation", ppToken->name);
                 else
-                    parseContext.ppError(ppToken->loc, message, "preprocessor evaluation", ppToken->name);
+                    _parseContext.ppError(ppToken->loc, message, "preprocessor evaluation", ppToken->name);
             }
         }
         token = scanToken(ppToken);
@@ -543,7 +543,7 @@ int TPpContext::CPPif(TPpToken* ppToken)
 {
     int token = scanToken(ppToken);
     if (ifdepth >= maxIfNesting || elsetracker >= maxIfNesting) {
-        parseContext.ppError(ppToken->loc, "maximum nesting depth exceeded", "#if", "");
+        _parseContext.ppError(ppToken->loc, "maximum nesting depth exceeded", "#if", "");
         return EndOfInput;
     } else {
         elsetracker++;
@@ -564,7 +564,7 @@ int TPpContext::CPPifdef(int defined, TPpToken* ppToken)
 {
     int token = scanToken(ppToken);
     if (ifdepth > maxIfNesting || elsetracker > maxIfNesting) {
-        parseContext.ppError(ppToken->loc, "maximum nesting depth exceeded", "#ifdef", "");
+        _parseContext.ppError(ppToken->loc, "maximum nesting depth exceeded", "#ifdef", "");
         return EndOfInput;
     } else {
         elsetracker++;
@@ -573,14 +573,14 @@ int TPpContext::CPPifdef(int defined, TPpToken* ppToken)
 
     if (token != PpAtomIdentifier) {
         if (defined)
-            parseContext.ppError(ppToken->loc, "must be followed by macro name", "#ifdef", "");
+            _parseContext.ppError(ppToken->loc, "must be followed by macro name", "#ifdef", "");
         else
-            parseContext.ppError(ppToken->loc, "must be followed by macro name", "#ifndef", "");
+            _parseContext.ppError(ppToken->loc, "must be followed by macro name", "#ifndef", "");
     } else {
         MacroSymbol* macro = lookupMacroDef(atomStrings.getAtom(ppToken->name));
         token = scanToken(ppToken);
         if (token != '\n') {
-            parseContext.ppError(ppToken->loc, "unexpected tokens following #ifdef directive - expected a newline", "#ifdef", "");
+            _parseContext.ppError(ppToken->loc, "unexpected tokens following #ifdef directive - expected a newline", "#ifdef", "");
             while (token != '\n' && token != EndOfInput)
                 token = scanToken(ppToken);
         }
@@ -607,7 +607,7 @@ int TPpContext::CPPinclude(TPpToken* ppToken)
     // otherwise ppToken already has the header name and it was "header-name" style
 
     if (token != PpAtomConstString) {
-        parseContext.ppError(directiveLoc, "must be followed by a header name", "#include", "");
+        _parseContext.ppError(directiveLoc, "must be followed by a header name", "#include", "");
         return token;
     }
 
@@ -618,9 +618,9 @@ int TPpContext::CPPinclude(TPpToken* ppToken)
     token = scanToken(ppToken);
     if (token != '\n') {
         if (token == EndOfInput)
-            parseContext.ppError(ppToken->loc, "expected newline after header name:", "#include", "%s", filename.c_str());
+            _parseContext.ppError(ppToken->loc, "expected newline after header name:", "#include", "%s", filename.c_str());
         else
-            parseContext.ppError(ppToken->loc, "extra content after header name:", "#include", "%s", filename.c_str());
+            _parseContext.ppError(ppToken->loc, "extra content after header name:", "#include", "%s", filename.c_str());
         return token;
     }
 
@@ -640,7 +640,7 @@ int TPpContext::CPPinclude(TPpToken* ppToken)
     if (res != nullptr && !res->headerName.empty()) {
         if (res->headerData != nullptr && res->headerLength > 0) {
             // path for processing one or more tokens from an included header, hand off 'res'
-            const bool forNextLine = parseContext.lineDirectiveShouldSetNextLine();
+            const bool forNextLine = _parseContext.lineDirectiveShouldSetNextLine();
             std::ostringstream prologue;
             std::ostringstream epilogue;
             prologue << "#line " << forNextLine << " " << "\"" << res->headerName << "\"\n";
@@ -648,7 +648,7 @@ int TPpContext::CPPinclude(TPpToken* ppToken)
                 "#line " << directiveLoc.line + forNextLine << " " << directiveLoc.getStringNameOrNum() << "\n";
             pushInput(new TokenizableIncludeFile(directiveLoc, prologue.str(), res, epilogue.str(), this));
             // There's no "current" location anymore.
-            parseContext.setCurrentColumn(0);
+            _parseContext.setCurrentColumn(0);
         } else {
             // things are okay, but there is nothing to process
             includer.releaseInclude(res);
@@ -658,7 +658,7 @@ int TPpContext::CPPinclude(TPpToken* ppToken)
         std::string message =
             res != nullptr ? std::string(res->headerData, res->headerLength)
                            : std::string("Could not process include directive");
-        parseContext.ppError(directiveLoc, message.c_str(), "#include", "for header name: %s", filename.c_str());
+        _parseContext.ppError(directiveLoc, message.c_str(), "#include", "for header name: %s", filename.c_str());
         includer.releaseInclude(res);
     }
 
@@ -675,7 +675,7 @@ int TPpContext::CPPline(TPpToken* ppToken)
     int token = scanToken(ppToken);
     const TSourceLoc directiveLoc = ppToken->loc;
     if (token == '\n') {
-        parseContext.ppError(ppToken->loc, "must by followed by an integral literal", "#line", "");
+        _parseContext.ppError(ppToken->loc, "must by followed by an integral literal", "#line", "");
         return token;
     }
 
@@ -692,31 +692,31 @@ int TPpContext::CPPline(TPpToken* ppToken)
         if (token == '\n')
             ++lineRes;
 
-        if (parseContext.lineDirectiveShouldSetNextLine())
+        if (_parseContext.lineDirectiveShouldSetNextLine())
             --lineRes;
-        parseContext.setCurrentLine(lineRes);
+        _parseContext.setCurrentLine(lineRes);
 
         if (token != '\n') {
             if (token == PpAtomConstString) {
-                parseContext.ppRequireExtensions(directiveLoc, 1, &E_GL_GOOGLE_cpp_style_line_directive, "filename-based #line");
+                _parseContext.ppRequireExtensions(directiveLoc, 1, &E_GL_GOOGLE_cpp_style_line_directive, "filename-based #line");
                 // We need to save a copy of the string instead of pointing
                 // to the name field of the token since the name field
                 // will likely be overwritten by the next token scan.
                 sourceName = atomStrings.getString(atomStrings.getAddAtom(ppToken->name));
-                parseContext.setCurrentSourceName(sourceName);
+                _parseContext.setCurrentSourceName(sourceName);
                 hasFile = true;
                 token = scanToken(ppToken);
             } else {
                 token = eval(token, MIN_PRECEDENCE, false, fileRes, fileErr, ppToken);
                 if (! fileErr) {
-                    parseContext.setCurrentString(fileRes);
+                    _parseContext.setCurrentString(fileRes);
                     hasFile = true;
                 }
             }
         }
     }
     if (!fileErr && !lineErr) {
-        parseContext.notifyLineDirective(directiveLoc.line, lineToken, hasFile, fileRes, sourceName);
+        _parseContext.notifyLineDirective(directiveLoc.line, lineToken, hasFile, fileRes, sourceName);
     }
     token = extraTokenCheck(PpAtomLine, ppToken, token);
 
@@ -745,9 +745,9 @@ int TPpContext::CPPerror(TPpToken* ppToken)
         message.append(" ");
         token = scanToken(ppToken);
     }
-    parseContext.notifyErrorDirective(loc.line, message.c_str());
+    _parseContext.notifyErrorDirective(loc.line, message.c_str());
     // store this msg into the shader's information log..set the Compile Error flag!!!!
-    parseContext.ppError(loc, message.c_str(), "#error", "");
+    _parseContext.ppError(loc, message.c_str(), "#error", "");
 
     return '\n';
 }
@@ -785,9 +785,9 @@ int TPpContext::CPPpragma(TPpToken* ppToken)
     }
 
     if (token == EndOfInput)
-        parseContext.ppError(loc, "directive must end with a newline", "#pragma", "");
+        _parseContext.ppError(loc, "directive must end with a newline", "#pragma", "");
     else
-        parseContext.handlePragma(loc, tokens);
+        _parseContext.handlePragma(loc, tokens);
 
     return token;
 }
@@ -798,21 +798,21 @@ int TPpContext::CPPversion(TPpToken* ppToken)
     int token = scanToken(ppToken);
 
     if (errorOnVersion || versionSeen) {
-        if (parseContext.isReadingHLSL())
-            parseContext.ppError(ppToken->loc, "invalid preprocessor command", "#version", "");
+        if (_parseContext.isReadingHLSL())
+            _parseContext.ppError(ppToken->loc, "invalid preprocessor command", "#version", "");
         else
-            parseContext.ppError(ppToken->loc, "must occur first in shader", "#version", "");
+            _parseContext.ppError(ppToken->loc, "must occur first in shader", "#version", "");
     }
     versionSeen = true;
 
     if (token == '\n') {
-        parseContext.ppError(ppToken->loc, "must be followed by version number", "#version", "");
+        _parseContext.ppError(ppToken->loc, "must be followed by version number", "#version", "");
 
         return token;
     }
 
     if (token != PpAtomConstInt)
-        parseContext.ppError(ppToken->loc, "must be followed by version number", "#version", "");
+        _parseContext.ppError(ppToken->loc, "must be followed by version number", "#version", "");
 
     ppToken->ival = atoi(ppToken->name);
     int versionNumber = ppToken->ival;
@@ -820,21 +820,21 @@ int TPpContext::CPPversion(TPpToken* ppToken)
     token = scanToken(ppToken);
 
     if (token == '\n') {
-        parseContext.notifyVersion(line, versionNumber, nullptr);
+        _parseContext.notifyVersion(line, versionNumber, nullptr);
         return token;
     } else {
         int profileAtom = atomStrings.getAtom(ppToken->name);
         if (profileAtom != PpAtomCore &&
             profileAtom != PpAtomCompatibility &&
             profileAtom != PpAtomEs)
-            parseContext.ppError(ppToken->loc, "bad profile name; use es, core, or compatibility", "#version", "");
-        parseContext.notifyVersion(line, versionNumber, ppToken->name);
+            _parseContext.ppError(ppToken->loc, "bad profile name; use es, core, or compatibility", "#version", "");
+        _parseContext.notifyVersion(line, versionNumber, ppToken->name);
         token = scanToken(ppToken);
 
         if (token == '\n')
             return token;
         else
-            parseContext.ppError(ppToken->loc, "bad tokens following profile -- expected newline", "#version", "");
+            _parseContext.ppError(ppToken->loc, "bad tokens following profile -- expected newline", "#version", "");
     }
 
     return token;
@@ -848,36 +848,36 @@ int TPpContext::CPPextension(TPpToken* ppToken)
     char extensionName[MaxTokenLength + 1];
 
     if (token=='\n') {
-        parseContext.ppError(ppToken->loc, "extension name not specified", "#extension", "");
+        _parseContext.ppError(ppToken->loc, "extension name not specified", "#extension", "");
         return token;
     }
 
     if (token != PpAtomIdentifier)
-        parseContext.ppError(ppToken->loc, "extension name expected", "#extension", "");
+        _parseContext.ppError(ppToken->loc, "extension name expected", "#extension", "");
 
     assert(strlen(ppToken->name) <= MaxTokenLength);
     strcpy(extensionName, ppToken->name);
 
     token = scanToken(ppToken);
     if (token != ':') {
-        parseContext.ppError(ppToken->loc, "':' missing after extension name", "#extension", "");
+        _parseContext.ppError(ppToken->loc, "':' missing after extension name", "#extension", "");
         return token;
     }
 
     token = scanToken(ppToken);
     if (token != PpAtomIdentifier) {
-        parseContext.ppError(ppToken->loc, "behavior for extension not specified", "#extension", "");
+        _parseContext.ppError(ppToken->loc, "behavior for extension not specified", "#extension", "");
         return token;
     }
 
-    parseContext.updateExtensionBehavior(line, extensionName, ppToken->name);
-    parseContext.notifyExtensionDirective(line, extensionName, ppToken->name);
+    _parseContext.updateExtensionBehavior(line, extensionName, ppToken->name);
+    _parseContext.notifyExtensionDirective(line, extensionName, ppToken->name);
 
     token = scanToken(ppToken);
     if (token == '\n')
         return token;
     else
-        parseContext.ppError(ppToken->loc,  "extra tokens -- expected newline", "#extension","");
+        _parseContext.ppError(ppToken->loc,  "extra tokens -- expected newline", "#extension","");
 
     return token;
 }
@@ -893,18 +893,18 @@ int TPpContext::readCPPline(TPpToken* ppToken)
             break;
         case PpAtomElse:
             if (elseSeen[elsetracker])
-                parseContext.ppError(ppToken->loc, "#else after #else", "#else", "");
+                _parseContext.ppError(ppToken->loc, "#else after #else", "#else", "");
             elseSeen[elsetracker] = true;
             if (ifdepth == 0)
-                parseContext.ppError(ppToken->loc, "mismatched statements", "#else", "");
+                _parseContext.ppError(ppToken->loc, "mismatched statements", "#else", "");
             token = extraTokenCheck(PpAtomElse, ppToken, scanToken(ppToken));
             token = CPPelse(0, ppToken);
             break;
         case PpAtomElif:
             if (ifdepth == 0)
-                parseContext.ppError(ppToken->loc, "mismatched statements", "#elif", "");
+                _parseContext.ppError(ppToken->loc, "mismatched statements", "#elif", "");
             if (elseSeen[elsetracker])
-                parseContext.ppError(ppToken->loc, "#elif after #else", "#elif", "");
+                _parseContext.ppError(ppToken->loc, "#elif after #else", "#elif", "");
             // this token is really a dont care, but we still need to eat the tokens
             token = scanToken(ppToken);
             while (token != '\n' && token != EndOfInput)
@@ -913,7 +913,7 @@ int TPpContext::readCPPline(TPpToken* ppToken)
             break;
         case PpAtomEndif:
             if (ifdepth == 0)
-                parseContext.ppError(ppToken->loc, "mismatched statements", "#endif", "");
+                _parseContext.ppError(ppToken->loc, "mismatched statements", "#endif", "");
             else {
                 elseSeen[elsetracker] = false;
                 --elsetracker;
@@ -931,8 +931,8 @@ int TPpContext::readCPPline(TPpToken* ppToken)
             token = CPPifdef(0, ppToken);
             break;
         case PpAtomInclude:
-            if(!parseContext.isReadingHLSL()) {
-                parseContext.ppRequireExtensions(ppToken->loc, 1, &E_GL_GOOGLE_include_directive, "#include");
+            if(!_parseContext.isReadingHLSL()) {
+                _parseContext.ppRequireExtensions(ppToken->loc, 1, &E_GL_GOOGLE_include_directive, "#include");
             }
             token = CPPinclude(ppToken);
             break;
@@ -955,11 +955,11 @@ int TPpContext::readCPPline(TPpToken* ppToken)
             token = CPPextension(ppToken);
             break;
         default:
-            parseContext.ppError(ppToken->loc, "invalid directive:", "#", ppToken->name);
+            _parseContext.ppError(ppToken->loc, "invalid directive:", "#", ppToken->name);
             break;
         }
     } else if (token != '\n' && token != EndOfInput)
-        parseContext.ppError(ppToken->loc, "invalid directive", "#", "");
+        _parseContext.ppError(ppToken->loc, "invalid directive", "#", "");
 
     while (token != '\n' && token != EndOfInput)
         token = scanToken(ppToken);
@@ -986,7 +986,7 @@ int TPpContext::scanHeaderName(TPpToken* ppToken, char delimit)
         if (ch == delimit) {
             ppToken->name[len] = '\0';
             if (tooLong)
-                parseContext.ppError(ppToken->loc, "header name too long", "", "");
+                _parseContext.ppError(ppToken->loc, "header name too long", "", "");
             return PpAtomConstString;
         } else if (ch == EndOfInput)
             return EndOfInput;
@@ -1038,7 +1038,7 @@ int TPpContext::tMacroInput::scan(TPpToken* ppToken)
 {
     int token;
     do {
-        token = mac->body.getToken(pp->parseContext, ppToken);
+        token = mac->body.getToken(pp->_parseContext, ppToken);
     } while (token == ' ');  // handle white space in macro
 
     // Hash operators basically turn off a round of macro substitution
@@ -1075,7 +1075,7 @@ int TPpContext::tMacroInput::scan(TPpToken* ppToken)
     }
 
     // HLSL does expand macros before concatenation
-    if (pasting && pp->parseContext.isReadingHLSL())
+    if (pasting && pp->_parseContext.isReadingHLSL())
         pasting = false;
 
     // TODO: preprocessor:  properly handle whitespace (or lack of it) between tokens when expanding
@@ -1128,22 +1128,22 @@ int TPpContext::MacroExpand(TPpToken* ppToken, bool expandUndef, bool newLineOka
     int macroAtom = atomStrings.getAtom(ppToken->name);
     switch (macroAtom) {
     case PpAtomLineMacro:
-        ppToken->ival = parseContext.getCurrentLoc().line;
+        ppToken->ival = _parseContext.getCurrentLoc().line;
         snprintf(ppToken->name, sizeof(ppToken->name), "%d", ppToken->ival);
         UngetToken(PpAtomConstInt, ppToken);
         return 1;
 
     case PpAtomFileMacro: {
-        if (parseContext.getCurrentLoc().name)
-            parseContext.ppRequireExtensions(ppToken->loc, 1, &E_GL_GOOGLE_cpp_style_line_directive, "filename-based __FILE__");
-        ppToken->ival = parseContext.getCurrentLoc().string;
+        if (_parseContext.getCurrentLoc().name)
+            _parseContext.ppRequireExtensions(ppToken->loc, 1, &E_GL_GOOGLE_cpp_style_line_directive, "filename-based __FILE__");
+        ppToken->ival = _parseContext.getCurrentLoc().string;
         snprintf(ppToken->name, sizeof(ppToken->name), "%s", ppToken->loc.getStringNameOrNum().c_str());
         UngetToken(PpAtomConstInt, ppToken);
         return 1;
     }
 
     case PpAtomVersionMacro:
-        ppToken->ival = parseContext.version;
+        ppToken->ival = _parseContext.version;
         snprintf(ppToken->name, sizeof(ppToken->name), "%d", ppToken->ival);
         UngetToken(PpAtomConstInt, ppToken);
         return 1;
@@ -1197,20 +1197,20 @@ int TPpContext::MacroExpand(TPpToken* ppToken, bool expandUndef, bool newLineOka
             while (1) {
                 token = scanToken(ppToken);
                 if (token == EndOfInput || token == tMarkerInput::marker) {
-                    parseContext.ppError(loc, "End of input in macro", "macro expansion", atomStrings.getString(macroAtom));
+                    _parseContext.ppError(loc, "End of input in macro", "macro expansion", atomStrings.getString(macroAtom));
                     delete in;
                     return 0;
                 }
                 if (token == '\n') {
                     if (! newLineOkay) {
-                        parseContext.ppError(loc, "End of line in macro substitution:", "macro expansion", atomStrings.getString(macroAtom));
+                        _parseContext.ppError(loc, "End of line in macro substitution:", "macro expansion", atomStrings.getString(macroAtom));
                         delete in;
                         return 0;
                     }
                     continue;
                 }
                 if (token == '#') {
-                    parseContext.ppError(ppToken->loc, "unexpected '#'", "macro expansion", atomStrings.getString(macroAtom));
+                    _parseContext.ppError(ppToken->loc, "unexpected '#'", "macro expansion", atomStrings.getString(macroAtom));
                     delete in;
                     return 0;
                 }
@@ -1235,7 +1235,7 @@ int TPpContext::MacroExpand(TPpToken* ppToken, bool expandUndef, bool newLineOka
         } while (arg < in->mac->args.size());
 
         if (arg < in->mac->args.size())
-            parseContext.ppError(loc, "Too few args in Macro", "macro expansion", atomStrings.getString(macroAtom));
+            _parseContext.ppError(loc, "Too few args in Macro", "macro expansion", atomStrings.getString(macroAtom));
         else if (token != ')') {
             depth=0;
             while (token != EndOfInput && (depth > 0 || token != ')')) {
@@ -1247,11 +1247,11 @@ int TPpContext::MacroExpand(TPpToken* ppToken, bool expandUndef, bool newLineOka
             }
 
             if (token == EndOfInput) {
-                parseContext.ppError(loc, "End of input in macro", "macro expansion", atomStrings.getString(macroAtom));
+                _parseContext.ppError(loc, "End of input in macro", "macro expansion", atomStrings.getString(macroAtom));
                 delete in;
                 return 0;
             }
-            parseContext.ppError(loc, "Too many args in macro", "macro expansion", atomStrings.getString(macroAtom));
+            _parseContext.ppError(loc, "Too many args in macro", "macro expansion", atomStrings.getString(macroAtom));
         }
 
         // We need both expanded and non-expanded forms of the argument, for whether or
diff --git a/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpContext.cpp b/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpContext.cpp
index c89b37688a..83c9d7e8e1 100755
--- a/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpContext.cpp
+++ b/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpContext.cpp
@@ -84,7 +84,7 @@ NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 namespace glslang {
 
 TPpContext::TPpContext(TParseContextBase& pc, const std::string& rootFileName, TShader::Includer& inclr) :
-    preamble(0), strings(0), previous_token('\n'), parseContext(pc), includer(inclr), inComment(false),
+    preamble(0), strings(0), previous_token('\n'), _parseContext(pc), includer(inclr), inComment(false),
     rootFileName(rootFileName),
     currentSourceFile(rootFileName)
 {
diff --git a/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpContext.h b/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpContext.h
index b3a39c5cbc..6324923d75 100755
--- a/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpContext.h
+++ b/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpContext.h
@@ -291,7 +291,7 @@ protected:
 
     // Scanner data:
     int previous_token;
-    TParseContextBase& parseContext;
+    TParseContextBase& _parseContext;
 
     // Get the next token from *stack* of input sources, popping input sources
     // that are out of tokens, down until an input source is found that has a token.
@@ -411,7 +411,7 @@ protected:
     class tTokenInput : public tInput {
     public:
         tTokenInput(TPpContext* pp, TokenStream* t, bool prepasting) : tInput(pp), tokens(t), lastTokenPastes(prepasting) { }
-        virtual int scan(TPpToken *ppToken) override { return tokens->getToken(pp->parseContext, ppToken); }
+        virtual int scan(TPpToken *ppToken) override { return tokens->getToken(pp->_parseContext, ppToken); }
         virtual int getch() override { assert(0); return EndOfInput; }
         virtual void ungetch() override { assert(0); }
         virtual bool peekPasting() override { return tokens->peekTokenizedPasting(lastTokenPastes); }
@@ -450,7 +450,7 @@ protected:
                 // Move past escaped newlines, as many as sequentially exist
                 do {
                     if (input->peek() == '\r' || input->peek() == '\n') {
-                        bool allowed = pp->parseContext.lineContinuationCheck(input->getSourceLoc(), pp->inComment);
+                        bool allowed = pp->_parseContext.lineContinuationCheck(input->getSourceLoc(), pp->inComment);
                         if (! allowed && pp->inComment)
                             return '\\';
 
@@ -553,14 +553,14 @@ protected:
 
         void notifyActivated() override
         {
-            prevScanner = pp->parseContext.getScanner();
-            pp->parseContext.setScanner(&scanner);
+            prevScanner = pp->_parseContext.getScanner();
+            pp->_parseContext.setScanner(&scanner);
             pp->push_include(includedFile_);
         }
 
         void notifyDeleted() override
         {
-            pp->parseContext.setScanner(prevScanner);
+            pp->_parseContext.setScanner(prevScanner);
             pp->pop_include();
         }
 
diff --git a/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpScanner.cpp b/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpScanner.cpp
index 0c620a5f5b..c73d74178d 100755
--- a/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpScanner.cpp
+++ b/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpScanner.cpp
@@ -134,18 +134,18 @@ int TPpContext::lFloatConst(int len, int ch, TPpToken* ppToken)
         int firstDecimal = len;
 
         // 1.#INF or -1.#INF
-        if (ch == '#' && (ifdepth > 0 || parseContext.intermediate.getSource() == EShSourceHlsl)) {
+        if (ch == '#' && (ifdepth > 0 || _parseContext.intermediate.getSource() == EShSourceHlsl)) {
             if ((len <  2) ||
                 (len == 2 && ppToken->name[0] != '1') ||
                 (len == 3 && ppToken->name[1] != '1' && !(ppToken->name[0] == '-' || ppToken->name[0] == '+')) ||
                 (len >  3))
-                parseContext.ppError(ppToken->loc, "unexpected use of", "#", "");
+                _parseContext.ppError(ppToken->loc, "unexpected use of", "#", "");
             else {
                 // we have 1.# or -1.# or +1.#, check for 'INF'
                 if ((ch = getChar()) != 'I' ||
                     (ch = getChar()) != 'N' ||
                     (ch = getChar()) != 'F')
-                    parseContext.ppError(ppToken->loc, "expected 'INF'", "#", "");
+                    _parseContext.ppError(ppToken->loc, "expected 'INF'", "#", "");
                 else {
                     // we have [+-].#INF, and we are targeting IEEE 754, so wrap it up:
                     saveName('I');
@@ -213,7 +213,7 @@ int TPpContext::lFloatConst(int len, int ch, TPpToken* ppToken)
                     ch = getChar();
                 }
             } else {
-                parseContext.ppError(ppToken->loc, "bad character in float exponent", "", "");
+                _parseContext.ppError(ppToken->loc, "bad character in float exponent", "", "");
             }
         }
 
@@ -249,11 +249,11 @@ int TPpContext::lFloatConst(int len, int ch, TPpToken* ppToken)
     bool isDouble = false;
     bool isFloat16 = false;
     if (ch == 'l' || ch == 'L') {
-        if (ifdepth == 0 && parseContext.intermediate.getSource() == EShSourceGlsl)
-            parseContext.doubleCheck(ppToken->loc, "double floating-point suffix");
+        if (ifdepth == 0 && _parseContext.intermediate.getSource() == EShSourceGlsl)
+            _parseContext.doubleCheck(ppToken->loc, "double floating-point suffix");
         if (ifdepth == 0 && !hasDecimalOrExponent)
-            parseContext.ppError(ppToken->loc, "float literal needs a decimal point or exponent", "", "");
-        if (parseContext.intermediate.getSource() == EShSourceGlsl) {
+            _parseContext.ppError(ppToken->loc, "float literal needs a decimal point or exponent", "", "");
+        if (_parseContext.intermediate.getSource() == EShSourceGlsl) {
             int ch2 = getChar();
             if (ch2 != 'f' && ch2 != 'F') {
                 ungetChar();
@@ -263,16 +263,16 @@ int TPpContext::lFloatConst(int len, int ch, TPpToken* ppToken)
                 saveName(ch2);
                 isDouble = true;
             }
-        } else if (parseContext.intermediate.getSource() == EShSourceHlsl) {
+        } else if (_parseContext.intermediate.getSource() == EShSourceHlsl) {
             saveName(ch);
             isDouble = true;
         }
     } else if (ch == 'h' || ch == 'H') {
-        if (ifdepth == 0 && parseContext.intermediate.getSource() == EShSourceGlsl)
-            parseContext.float16Check(ppToken->loc, "half floating-point suffix");
+        if (ifdepth == 0 && _parseContext.intermediate.getSource() == EShSourceGlsl)
+            _parseContext.float16Check(ppToken->loc, "half floating-point suffix");
         if (ifdepth == 0 && !hasDecimalOrExponent)
-            parseContext.ppError(ppToken->loc, "float literal needs a decimal point or exponent", "", "");
-        if (parseContext.intermediate.getSource() == EShSourceGlsl) {
+            _parseContext.ppError(ppToken->loc, "float literal needs a decimal point or exponent", "", "");
+        if (_parseContext.intermediate.getSource() == EShSourceGlsl) {
             int ch2 = getChar();
             if (ch2 != 'f' && ch2 != 'F') {
                 ungetChar();
@@ -282,17 +282,17 @@ int TPpContext::lFloatConst(int len, int ch, TPpToken* ppToken)
                 saveName(ch2);
                 isFloat16 = true;
             }
-        } else if (parseContext.intermediate.getSource() == EShSourceHlsl) {
+        } else if (_parseContext.intermediate.getSource() == EShSourceHlsl) {
             saveName(ch);
             isFloat16 = true;
         }
     } else if (ch == 'f' || ch == 'F') {
         if (ifdepth == 0)
-            parseContext.profileRequires(ppToken->loc,  EEsProfile, 300, nullptr, "floating-point suffix");
-        if (ifdepth == 0 && !parseContext.relaxedErrors())
-            parseContext.profileRequires(ppToken->loc, ~EEsProfile, 120, nullptr, "floating-point suffix");
+            _parseContext.profileRequires(ppToken->loc,  EEsProfile, 300, nullptr, "floating-point suffix");
+        if (ifdepth == 0 && !_parseContext.relaxedErrors())
+            _parseContext.profileRequires(ppToken->loc, ~EEsProfile, 120, nullptr, "floating-point suffix");
         if (ifdepth == 0 && !hasDecimalOrExponent)
-            parseContext.ppError(ppToken->loc, "float literal needs a decimal point or exponent", "", "");
+            _parseContext.ppError(ppToken->loc, "float literal needs a decimal point or exponent", "", "");
         saveName(ch);
     } else
         ungetChar();
@@ -301,7 +301,7 @@ int TPpContext::lFloatConst(int len, int ch, TPpToken* ppToken)
 
     if (len > MaxTokenLength) {
         len = MaxTokenLength;
-        parseContext.ppError(ppToken->loc, "float literal too long", "", "");
+        _parseContext.ppError(ppToken->loc, "float literal too long", "", "");
     }
     ppToken->name[len] = '\0';
 
@@ -349,7 +349,7 @@ int TPpContext::characterLiteral(TPpToken* ppToken)
     ppToken->name[0] = 0;
     ppToken->ival = 0;
 
-    if (parseContext.intermediate.getSource() != EShSourceHlsl) {
+    if (_parseContext.intermediate.getSource() != EShSourceHlsl) {
         // illegal, except in macro definition, for which case we report the character
         return '\'';
     }
@@ -358,7 +358,7 @@ int TPpContext::characterLiteral(TPpToken* ppToken)
     switch (ch) {
     case '\'':
         // As empty sequence:  ''
-        parseContext.ppError(ppToken->loc, "unexpected", "\'", "");
+        _parseContext.ppError(ppToken->loc, "unexpected", "\'", "");
         return PpAtomConstInt;
     case '\\':
         // As escape sequence:  '\XXX'
@@ -386,7 +386,7 @@ int TPpContext::characterLiteral(TPpToken* ppToken)
             break;
         case 'x':
         case '0':
-            parseContext.ppError(ppToken->loc, "octal and hex sequences not supported", "\\", "");
+            _parseContext.ppError(ppToken->loc, "octal and hex sequences not supported", "\\", "");
             break;
         default:
             // This catches '\'', '\"', '\?', etc.
@@ -404,7 +404,7 @@ int TPpContext::characterLiteral(TPpToken* ppToken)
     ppToken->name[1] = '\0';
     ch = getChar();
     if (ch != '\'') {
-        parseContext.ppError(ppToken->loc, "expected", "\'", "");
+        _parseContext.ppError(ppToken->loc, "expected", "\'", "");
         // Look ahead for a closing '
         do {
             ch = getChar();
@@ -452,7 +452,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
             ch = getch();
         }
 
-        ppToken->loc = pp->parseContext.getCurrentLoc();
+        ppToken->loc = pp->_parseContext.getCurrentLoc();
         len = 0;
         switch (ch) {
         default:
@@ -479,7 +479,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                     ch = getch();
                 } else {
                     if (! AlreadyComplained) {
-                        pp->parseContext.ppError(ppToken->loc, "name too long", "", "");
+                        pp->_parseContext.ppError(ppToken->loc, "name too long", "", "");
                         AlreadyComplained = 1;
                     }
                     ch = getch();
@@ -522,14 +522,14 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                             } else if (ch >= 'a' && ch <= 'f') {
                                 ii = ch - 'a' + 10;
                             } else
-                                pp->parseContext.ppError(ppToken->loc, "bad digit in hexadecimal literal", "", "");
+                                pp->_parseContext.ppError(ppToken->loc, "bad digit in hexadecimal literal", "", "");
                             ival = (ival << 4) | ii;
                         } else {
                             if (! AlreadyComplained) {
                                 if(len < MaxTokenLength)
-                                    pp->parseContext.ppError(ppToken->loc, "hexadecimal literal too big", "", "");
+                                    pp->_parseContext.ppError(ppToken->loc, "hexadecimal literal too big", "", "");
                                 else
-                                    pp->parseContext.ppError(ppToken->loc, "hexadecimal literal too long", "", "");
+                                    pp->_parseContext.ppError(ppToken->loc, "hexadecimal literal too long", "", "");
                                 AlreadyComplained = 1;
                             }
                             ival = 0xffffffffffffffffull;
@@ -539,7 +539,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                              (ch >= 'A' && ch <= 'F') ||
                              (ch >= 'a' && ch <= 'f'));
                 } else {
-                    pp->parseContext.ppError(ppToken->loc, "bad digit in hexadecimal literal", "", "");
+                    pp->_parseContext.ppError(ppToken->loc, "bad digit in hexadecimal literal", "", "");
                 }
                 if (ch == 'u' || ch == 'U') {
                     if (len < MaxTokenLength)
@@ -557,7 +557,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
 #ifdef AMD_EXTENSIONS
                     nextCh = getch();
                     if ((nextCh == 's' || nextCh == 'S') &&
-                            pp->parseContext.intermediate.getSource() == EShSourceGlsl) {
+                            pp->_parseContext.intermediate.getSource() == EShSourceGlsl) {
                         if (len < MaxTokenLength)
                             ppToken->name[len++] = (char)nextCh;
                         isInt16 = true;
@@ -570,7 +570,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                     isInt64 = true;
 #ifdef AMD_EXTENSIONS
                 } else if ((ch == 's' || ch == 'S') &&
-                           pp->parseContext.intermediate.getSource() == EShSourceGlsl) {
+                           pp->_parseContext.intermediate.getSource() == EShSourceGlsl) {
                     if (len < MaxTokenLength)
                         ppToken->name[len++] = (char)ch;
                     isInt16 = true;
@@ -579,21 +579,21 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                     ungetch();
                 ppToken->name[len] = '\0';
 
-                if (isInt64 && pp->parseContext.intermediate.getSource() == EShSourceGlsl) {
+                if (isInt64 && pp->_parseContext.intermediate.getSource() == EShSourceGlsl) {
                     if (pp->ifdepth == 0) {
-                        pp->parseContext.requireProfile(ppToken->loc, ~EEsProfile,
+                        pp->_parseContext.requireProfile(ppToken->loc, ~EEsProfile,
                                                         "64-bit hexadecimal literal");
-                        pp->parseContext.profileRequires(ppToken->loc, ~EEsProfile, 0,
+                        pp->_parseContext.profileRequires(ppToken->loc, ~EEsProfile, 0,
                             Num_Int64_Extensions, Int64_Extensions, "64-bit hexadecimal literal");
                     }
                     ppToken->i64val = ival;
                     return isUnsigned ? PpAtomConstUint64 : PpAtomConstInt64;
                 } else if (isInt16) {
                     if (pp->ifdepth == 0) {
-                        if (pp->parseContext.intermediate.getSource() == EShSourceGlsl) {
-                            pp->parseContext.requireProfile(ppToken->loc, ~EEsProfile,
+                        if (pp->_parseContext.intermediate.getSource() == EShSourceGlsl) {
+                            pp->_parseContext.requireProfile(ppToken->loc, ~EEsProfile,
                                                              "16-bit hexadecimal literal");
-                            pp->parseContext.profileRequires(ppToken->loc, ~EEsProfile, 0,
+                            pp->_parseContext.profileRequires(ppToken->loc, ~EEsProfile, 0,
                                 Num_Int16_Extensions, Int16_Extensions, "16-bit hexadecimal literal");
                         }
                     }
@@ -601,7 +601,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                     return isUnsigned ? PpAtomConstUint16 : PpAtomConstInt16;
                 } else {
                     if (ival > 0xffffffffu && !AlreadyComplained)
-                        pp->parseContext.ppError(ppToken->loc, "hexadecimal literal too big", "", "");
+                        pp->_parseContext.ppError(ppToken->loc, "hexadecimal literal too big", "", "");
                     ppToken->ival = (int)ival;
                     return isUnsigned ? PpAtomConstUint : PpAtomConstInt;
                 }
@@ -620,7 +620,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                     if (len < MaxTokenLength)
                         ppToken->name[len++] = (char)ch;
                     else if (! AlreadyComplained) {
-                        pp->parseContext.ppError(ppToken->loc, "numeric literal too long", "", "");
+                        pp->_parseContext.ppError(ppToken->loc, "numeric literal too long", "", "");
                         AlreadyComplained = 1;
                     }
                     if (ival <= 0x1fffffffffffffffull) {
@@ -638,7 +638,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                         if (len < MaxTokenLength)
                             ppToken->name[len++] = (char)ch;
                         else if (! AlreadyComplained) {
-                            pp->parseContext.ppError(ppToken->loc, "numeric literal too long", "", "");
+                            pp->_parseContext.ppError(ppToken->loc, "numeric literal too long", "", "");
                             AlreadyComplained = 1;
                         }
                         ch = getch();
@@ -649,7 +649,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
 
                 // wasn't a float, so must be octal...
                 if (nonOctal)
-                    pp->parseContext.ppError(ppToken->loc, "octal literal digit too large", "", "");
+                    pp->_parseContext.ppError(ppToken->loc, "octal literal digit too large", "", "");
 
                 if (ch == 'u' || ch == 'U') {
                     if (len < MaxTokenLength)
@@ -667,7 +667,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
 #ifdef AMD_EXTENSIONS
                     nextCh = getch();
                     if ((nextCh == 's' || nextCh == 'S') && 
-                                pp->parseContext.intermediate.getSource() == EShSourceGlsl) {
+                                pp->_parseContext.intermediate.getSource() == EShSourceGlsl) {
                         if (len < MaxTokenLength)
                             ppToken->name[len++] = (char)nextCh;
                         isInt16 = true;
@@ -680,7 +680,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                     isInt64 = true;
 #ifdef AMD_EXTENSIONS
                 } else if ((ch == 's' || ch == 'S') && 
-                                pp->parseContext.intermediate.getSource() == EShSourceGlsl) {
+                                pp->_parseContext.intermediate.getSource() == EShSourceGlsl) {
                     if (len < MaxTokenLength)
                         ppToken->name[len++] = (char)ch;
                     isInt16 = true;
@@ -693,23 +693,23 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                     octalOverflow = true;
 
                 if (octalOverflow)
-                    pp->parseContext.ppError(ppToken->loc, "octal literal too big", "", "");
+                    pp->_parseContext.ppError(ppToken->loc, "octal literal too big", "", "");
 
-                if (isInt64 && pp->parseContext.intermediate.getSource() == EShSourceGlsl) {
+                if (isInt64 && pp->_parseContext.intermediate.getSource() == EShSourceGlsl) {
                     if (pp->ifdepth == 0) {
-                        pp->parseContext.requireProfile(ppToken->loc, ~EEsProfile,
+                        pp->_parseContext.requireProfile(ppToken->loc, ~EEsProfile,
                                                         "64-bit octal literal");
-                        pp->parseContext.profileRequires(ppToken->loc, ~EEsProfile, 0,
+                        pp->_parseContext.profileRequires(ppToken->loc, ~EEsProfile, 0,
                             Num_Int64_Extensions, Int64_Extensions, "64-bit octal literal");
                     }
                     ppToken->i64val = ival;
                     return isUnsigned ? PpAtomConstUint64 : PpAtomConstInt64;
                 } else if (isInt16) {
                     if (pp->ifdepth == 0) {
-                        if (pp->parseContext.intermediate.getSource() == EShSourceGlsl) {
-                            pp->parseContext.requireProfile(ppToken->loc, ~EEsProfile,
+                        if (pp->_parseContext.intermediate.getSource() == EShSourceGlsl) {
+                            pp->_parseContext.requireProfile(ppToken->loc, ~EEsProfile,
                                                             "16-bit octal literal");
-                            pp->parseContext.profileRequires(ppToken->loc, ~EEsProfile, 0,
+                            pp->_parseContext.profileRequires(ppToken->loc, ~EEsProfile, 0,
                                 Num_Int16_Extensions, Int16_Extensions, "16-bit octal literal");
                         }
                     }
@@ -729,7 +729,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                 if (len < MaxTokenLength)
                     ppToken->name[len++] = (char)ch;
                 else if (! AlreadyComplained) {
-                    pp->parseContext.ppError(ppToken->loc, "numeric literal too long", "", "");
+                    pp->_parseContext.ppError(ppToken->loc, "numeric literal too long", "", "");
                     AlreadyComplained = 1;
                 }
                 ch = getch();
@@ -758,7 +758,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
 #ifdef AMD_EXTENSIONS
                     nextCh = getch();
                     if ((nextCh == 's' || nextCh == 'S') &&
-                                pp->parseContext.intermediate.getSource() == EShSourceGlsl) {
+                                pp->_parseContext.intermediate.getSource() == EShSourceGlsl) {
                         if (len < MaxTokenLength)
                             ppToken->name[len++] = (char)nextCh;
                         isInt16 = true;
@@ -771,7 +771,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                     isInt64 = true;
 #ifdef AMD_EXTENSIONS
                 } else if ((ch == 's' || ch == 'S') &&
-                                pp->parseContext.intermediate.getSource() == EShSourceGlsl) {
+                                pp->_parseContext.intermediate.getSource() == EShSourceGlsl) {
                     if (len < MaxTokenLength)
                         ppToken->name[len++] = (char)ch;
                     isInt16 = true;
@@ -797,27 +797,27 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                     else
                         overflow = (ival > oneTenthMaxInt || (ival == oneTenthMaxInt && (unsigned)ch > remainderMaxInt));
                     if (overflow) {
-                        pp->parseContext.ppError(ppToken->loc, "numeric literal too big", "", "");
+                        pp->_parseContext.ppError(ppToken->loc, "numeric literal too big", "", "");
                         ival = 0xFFFFFFFFFFFFFFFFull;
                         break;
                     } else
                         ival = ival * 10 + ch;
                 }
 
-                if (isInt64 && pp->parseContext.intermediate.getSource() == EShSourceGlsl) {
+                if (isInt64 && pp->_parseContext.intermediate.getSource() == EShSourceGlsl) {
                     if (pp->ifdepth == 0) {
-                        pp->parseContext.requireProfile(ppToken->loc, ~EEsProfile,
+                        pp->_parseContext.requireProfile(ppToken->loc, ~EEsProfile,
                                                         "64-bit literal");
-                        pp->parseContext.profileRequires(ppToken->loc, ~EEsProfile, 0,
+                        pp->_parseContext.profileRequires(ppToken->loc, ~EEsProfile, 0,
                             Num_Int64_Extensions, Int64_Extensions, "64-bit literal");
                     }
                     ppToken->i64val = ival;
                     return isUnsigned ? PpAtomConstUint64 : PpAtomConstInt64;
                 } else if (isInt16) {
-                    if (pp->ifdepth == 0 && pp->parseContext.intermediate.getSource() == EShSourceGlsl) {
-                        pp->parseContext.requireProfile(ppToken->loc, ~EEsProfile,
+                    if (pp->ifdepth == 0 && pp->_parseContext.intermediate.getSource() == EShSourceGlsl) {
+                        pp->_parseContext.requireProfile(ppToken->loc, ~EEsProfile,
                                                         "16-bit  literal");
-                        pp->parseContext.profileRequires(ppToken->loc, ~EEsProfile, 0,
+                        pp->_parseContext.profileRequires(ppToken->loc, ~EEsProfile, 0,
                             Num_Int16_Extensions, Int16_Extensions, "16-bit literal");
                     }
                     ppToken->ival = (int)ival;
@@ -970,14 +970,14 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
                 do {
                     while (ch != '*') {
                         if (ch == EndOfInput) {
-                            pp->parseContext.ppError(ppToken->loc, "End of input in comment", "comment", "");
+                            pp->_parseContext.ppError(ppToken->loc, "End of input in comment", "comment", "");
                             return ch;
                         }
                         ch = getch();
                     }
                     ch = getch();
                     if (ch == EndOfInput) {
-                        pp->parseContext.ppError(ppToken->loc, "End of input in comment", "comment", "");
+                        pp->_parseContext.ppError(ppToken->loc, "End of input in comment", "comment", "");
                         return ch;
                     }
                 } while (ch != '/');
@@ -1009,7 +1009,7 @@ int TPpContext::tStringInput::scan(TPpToken* ppToken)
             ppToken->name[len] = '\0';
             if (ch != '"') {
                 ungetch();
-                pp->parseContext.ppError(ppToken->loc, "End of line in string", "string", "");
+                pp->_parseContext.ppError(ppToken->loc, "End of line in string", "string", "");
             }
             return PpAtomConstString;
         case ':':
@@ -1051,7 +1051,7 @@ int TPpContext::tokenize(TPpToken& ppToken)
                 }
                 continue;
             } else {
-                parseContext.ppError(ppToken.loc, "preprocessor directive cannot be preceded by another token", "#", "");
+                _parseContext.ppError(ppToken.loc, "preprocessor directive cannot be preceded by another token", "#", "");
                 return EndOfInput;
             }
         }
@@ -1079,14 +1079,14 @@ int TPpContext::tokenize(TPpToken& ppToken)
                 continue;
             break;
         case PpAtomConstString:
-            if (ifdepth == 0 && parseContext.intermediate.getSource() != EShSourceHlsl) {
+            if (ifdepth == 0 && _parseContext.intermediate.getSource() != EShSourceHlsl) {
                 // HLSL allows string literals.
-                parseContext.ppError(ppToken.loc, "string literals not supported", "\"\"", "");
+                _parseContext.ppError(ppToken.loc, "string literals not supported", "\"\"", "");
                 continue;
             }
             break;
         case '\'':
-            parseContext.ppError(ppToken.loc, "character literals not supported", "\'", "");
+            _parseContext.ppError(ppToken.loc, "character literals not supported", "\'", "");
             continue;
         default:
             strcpy(ppToken.name, atomStrings.getString(token));
@@ -1106,7 +1106,7 @@ int TPpContext::tokenPaste(int token, TPpToken& ppToken)
 {
     // starting with ## is illegal, skip to next token
     if (token == PpAtomPaste) {
-        parseContext.ppError(ppToken.loc, "unexpected location", "##", "");
+        _parseContext.ppError(ppToken.loc, "unexpected location", "##", "");
         return scanToken(&ppToken);
     }
 
@@ -1122,7 +1122,7 @@ int TPpContext::tokenPaste(int token, TPpToken& ppToken)
 
         // This covers end of macro expansion
         if (endOfReplacementList()) {
-            parseContext.ppError(ppToken.loc, "unexpected location; end of replacement list", "##", "");
+            _parseContext.ppError(ppToken.loc, "unexpected location; end of replacement list", "##", "");
             break;
         }
 
@@ -1131,7 +1131,7 @@ int TPpContext::tokenPaste(int token, TPpToken& ppToken)
 
         // This covers end of argument expansion
         if (token == tMarkerInput::marker) {
-            parseContext.ppError(ppToken.loc, "unexpected location; end of argument", "##", "");
+            _parseContext.ppError(ppToken.loc, "unexpected location; end of argument", "##", "");
             break;
         }
 
@@ -1162,13 +1162,13 @@ int TPpContext::tokenPaste(int token, TPpToken& ppToken)
             strcpy(pastedPpToken.name, atomStrings.getString(token));
             break;
         default:
-            parseContext.ppError(ppToken.loc, "not supported for these tokens", "##", "");
+            _parseContext.ppError(ppToken.loc, "not supported for these tokens", "##", "");
             return resultToken;
         }
 
         // combine the tokens
         if (strlen(ppToken.name) + strlen(pastedPpToken.name) > MaxTokenLength) {
-            parseContext.ppError(ppToken.loc, "combined tokens are too long", "##", "");
+            _parseContext.ppError(ppToken.loc, "combined tokens are too long", "##", "");
             return resultToken;
         }
         strncat(ppToken.name, pastedPpToken.name, MaxTokenLength - strlen(ppToken.name));
@@ -1179,7 +1179,7 @@ int TPpContext::tokenPaste(int token, TPpToken& ppToken)
             if (newToken > 0)
                 resultToken = newToken;
             else
-                parseContext.ppError(ppToken.loc, "combined token is invalid", "##", "");
+                _parseContext.ppError(ppToken.loc, "combined token is invalid", "##", "");
         }
     }
 
@@ -1190,7 +1190,7 @@ int TPpContext::tokenPaste(int token, TPpToken& ppToken)
 void TPpContext::missingEndifCheck()
 {
     if (ifdepth > 0)
-        parseContext.ppError(parseContext.getCurrentLoc(), "missing #endif", "", "");
+        _parseContext.ppError(_parseContext.getCurrentLoc(), "missing #endif", "", "");
 }
 
 } // end namespace glslang
diff --git a/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpTokens.cpp b/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpTokens.cpp
index 7dc2722ce1..475d0aad3b 100755
--- a/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpTokens.cpp
+++ b/deps/glslang/glslang/glslang/MachineIndependent/preprocessor/PpTokens.cpp
@@ -195,7 +195,7 @@ void TPpContext::TokenStream::putToken(int atom, TPpToken* ppToken)
 
 // Read the next token from a token stream.
 // (Not the source stream, but a stream used to hold a tokenized macro).
-int TPpContext::TokenStream::getToken(TParseContextBase& parseContext, TPpToken *ppToken)
+int TPpContext::TokenStream::getToken(TParseContextBase& _parseContext, TPpToken *ppToken)
 {
     // get the atom
     int atom = getSubtoken();
@@ -204,7 +204,7 @@ int TPpContext::TokenStream::getToken(TParseContextBase& parseContext, TPpToken
 
     // init the token
     ppToken->clear();
-    ppToken->loc = parseContext.getCurrentLoc();
+    ppToken->loc = _parseContext.getCurrentLoc();
 
     // get the backing name string
     if (SaveName(atom)) {
@@ -216,7 +216,7 @@ int TPpContext::TokenStream::getToken(TParseContextBase& parseContext, TPpToken
                 len++;
                 ch = getSubtoken();
             } else {
-                parseContext.error(ppToken->loc, "token too long", "", "");
+                _parseContext.error(ppToken->loc, "token too long", "", "");
                 break;
             }
         }
@@ -227,8 +227,8 @@ int TPpContext::TokenStream::getToken(TParseContextBase& parseContext, TPpToken
     if (atom == '#') {
         if (current < data.size()) {
             if (getSubtoken() == '#') {
-                parseContext.requireProfile(ppToken->loc, ~EEsProfile, "token pasting (##)");
-                parseContext.profileRequires(ppToken->loc, ~EEsProfile, 130, 0, "token pasting (##)");
+                _parseContext.requireProfile(ppToken->loc, ~EEsProfile, "token pasting (##)");
+                _parseContext.profileRequires(ppToken->loc, ~EEsProfile, 130, 0, "token pasting (##)");
                 atom = PpAtomPaste;
             } else
                 ungetSubtoken();
diff --git a/deps/glslang/glslang/glslang/OSDependent/Windows/ossource.cpp b/deps/glslang/glslang/glslang/OSDependent/Windows/ossource.cpp
index 870840c56e..49c31492a1 100644
--- a/deps/glslang/glslang/glslang/OSDependent/Windows/ossource.cpp
+++ b/deps/glslang/glslang/glslang/OSDependent/Windows/ossource.cpp
@@ -34,6 +34,7 @@
 
 #include "../osinclude.h"
 
+#undef  STRICT
 #define STRICT
 #define VC_EXTRALEAN 1
 #include <windows.h>
diff --git a/deps/glslang/glslang/hlsl/hlslGrammar.cpp b/deps/glslang/glslang/hlsl/hlslGrammar.cpp
index cb05877917..aa05465abc 100755
--- a/deps/glslang/glslang/hlsl/hlslGrammar.cpp
+++ b/deps/glslang/glslang/hlsl/hlslGrammar.cpp
@@ -67,12 +67,12 @@ bool HlslGrammar::parse()
 
 void HlslGrammar::expected(const char* syntax)
 {
-    parseContext.error(token.loc, "Expected", syntax, "");
+    _parseContext.error(token.loc, "Expected", syntax, "");
 }
 
 void HlslGrammar::unimplemented(const char* error)
 {
-    parseContext.error(token.loc, "Unimplemented", error, "");
+    _parseContext.error(token.loc, "Unimplemented", error, "");
 }
 
 // IDENTIFIER
@@ -195,7 +195,7 @@ bool HlslGrammar::acceptSamplerState()
     if (! acceptTokenClass(EHTokLeftBrace))
         return true;
 
-    parseContext.warn(token.loc, "unimplemented", "immediate sampler state", "");
+    _parseContext.warn(token.loc, "unimplemented", "immediate sampler state", "");
 
     do {
         // read state name
@@ -337,7 +337,7 @@ bool HlslGrammar::acceptDeclaration(TIntermNode*& nodeList)
             expected("namespace name");
             return false;
         }
-        parseContext.pushNamespace(*namespaceToken.string);
+        _parseContext.pushNamespace(*namespaceToken.string);
         if (!acceptTokenClass(EHTokLeftBrace)) {
             expected("{");
             return false;
@@ -350,7 +350,7 @@ bool HlslGrammar::acceptDeclaration(TIntermNode*& nodeList)
             expected("}");
             return false;
         }
-        parseContext.popNamespace();
+        _parseContext.popNamespace();
         return true;
     }
 
@@ -391,16 +391,16 @@ bool HlslGrammar::acceptDeclaration(TIntermNode*& nodeList)
     TIntermAggregate* initializers = nullptr;
     while (acceptIdentifier(idToken)) {
         TString *fullName = idToken.string;
-        if (parseContext.symbolTable.atGlobalLevel())
-            parseContext.getFullNamespaceName(fullName);
+        if (_parseContext.symbolTable.atGlobalLevel())
+            _parseContext.getFullNamespaceName(fullName);
         if (peekTokenClass(EHTokLeftParen)) {
             // looks like function parameters
 
             // merge in the attributes into the return type
-            parseContext.transferTypeAttributes(token.loc, declarator.attributes, declaredType, true);
+            _parseContext.transferTypeAttributes(token.loc, declarator.attributes, declaredType, true);
 
             // Potentially rename shader entry point function.  No-op most of the time.
-            parseContext.renameShaderFunction(fullName);
+            _parseContext.renameShaderFunction(fullName);
 
             // function_parameters
             declarator.function = new TFunction(fullName, declaredType);
@@ -416,24 +416,24 @@ bool HlslGrammar::acceptDeclaration(TIntermNode*& nodeList)
             declarator.loc = token.loc;
             if (peekTokenClass(EHTokLeftBrace)) {
                 if (declarator_list)
-                    parseContext.error(idToken.loc, "function body can't be in a declarator list", "{", "");
+                    _parseContext.error(idToken.loc, "function body can't be in a declarator list", "{", "");
                 if (typedefDecl)
-                    parseContext.error(idToken.loc, "function body can't be in a typedef", "{", "");
+                    _parseContext.error(idToken.loc, "function body can't be in a typedef", "{", "");
                 return acceptFunctionDefinition(declarator, nodeList, nullptr);
             } else {
                 if (typedefDecl)
-                    parseContext.error(idToken.loc, "function typedefs not implemented", "{", "");
-                parseContext.handleFunctionDeclarator(declarator.loc, *declarator.function, true);
+                    _parseContext.error(idToken.loc, "function typedefs not implemented", "{", "");
+                _parseContext.handleFunctionDeclarator(declarator.loc, *declarator.function, true);
             }
         } else {
             // A variable declaration.
 
             // merge in the attributes, the first time around, into the shared type
             if (! declarator_list)
-                parseContext.transferTypeAttributes(token.loc, declarator.attributes, declaredType);
+                _parseContext.transferTypeAttributes(token.loc, declarator.attributes, declaredType);
 
             // Fix the storage qualifier if it's a global.
-            if (declaredType.getQualifier().storage == EvqTemporary && parseContext.symbolTable.atGlobalLevel())
+            if (declaredType.getQualifier().storage == EvqTemporary && _parseContext.symbolTable.atGlobalLevel())
                 declaredType.getQualifier().storage = EvqUniform;
 
             // recognize array_specifier
@@ -464,7 +464,7 @@ bool HlslGrammar::acceptDeclaration(TIntermNode*& nodeList)
             TIntermTyped* expressionNode = nullptr;
             if (acceptTokenClass(EHTokAssign)) {
                 if (typedefDecl)
-                    parseContext.error(idToken.loc, "can't have an initializer", "typedef", "");
+                    _parseContext.error(idToken.loc, "can't have an initializer", "typedef", "");
                 if (! acceptAssignmentExpression(expressionNode)) {
                     expected("initializer");
                     return false;
@@ -473,24 +473,24 @@ bool HlslGrammar::acceptDeclaration(TIntermNode*& nodeList)
 
             // TODO: things scoped within an annotation need their own name space;
             // TODO: strings are not yet handled.
-            if (variableType.getBasicType() != EbtString && parseContext.getAnnotationNestingLevel() == 0) {
+            if (variableType.getBasicType() != EbtString && _parseContext.getAnnotationNestingLevel() == 0) {
                 if (typedefDecl)
-                    parseContext.declareTypedef(idToken.loc, *fullName, variableType);
+                    _parseContext.declareTypedef(idToken.loc, *fullName, variableType);
                 else if (variableType.getBasicType() == EbtBlock) {
                     if (expressionNode)
-                        parseContext.error(idToken.loc, "buffer aliasing not yet supported", "block initializer", "");
-                    parseContext.declareBlock(idToken.loc, variableType, fullName);
-                    parseContext.declareStructBufferCounter(idToken.loc, variableType, *fullName);
+                        _parseContext.error(idToken.loc, "buffer aliasing not yet supported", "block initializer", "");
+                    _parseContext.declareBlock(idToken.loc, variableType, fullName);
+                    _parseContext.declareStructBufferCounter(idToken.loc, variableType, *fullName);
                 } else {
                     if (variableType.getQualifier().storage == EvqUniform && ! variableType.containsOpaque()) {
                         // this isn't really an individual variable, but a member of the $Global buffer
-                        parseContext.growGlobalUniformBlock(idToken.loc, variableType, *fullName);
+                        _parseContext.growGlobalUniformBlock(idToken.loc, variableType, *fullName);
                     } else {
                         // Declare the variable and add any initializer code to the AST.
                         // The top-level node is always made into an aggregate, as that's
                         // historically how the AST has been.
                         initializers = intermediate.growAggregate(initializers,
-                            parseContext.declareVariable(idToken.loc, *fullName, variableType, expressionNode),
+                            _parseContext.declareVariable(idToken.loc, *fullName, variableType, expressionNode),
                             idToken.loc);
                     }
                 }
@@ -544,7 +544,7 @@ bool HlslGrammar::acceptControlDeclaration(TIntermNode*& node)
         return false;
 
     if (attributes.size() > 0)
-        parseContext.warn(token.loc, "attributes don't apply to control declaration", "", "");
+        _parseContext.warn(token.loc, "attributes don't apply to control declaration", "", "");
 
     // filter out type casts
     if (peekTokenClass(EHTokLeftParen)) {
@@ -572,7 +572,7 @@ bool HlslGrammar::acceptControlDeclaration(TIntermNode*& node)
         return false;
     }
 
-    node = parseContext.declareVariable(idToken.loc, *idToken.string, type, expressionNode);
+    node = _parseContext.declareVariable(idToken.loc, *idToken.string, type, expressionNode);
 
     return true;
 }
@@ -608,16 +608,16 @@ bool HlslGrammar::acceptFullySpecifiedType(TType& type, TIntermNode*& nodeList,
 
     if (type.getBasicType() == EbtBlock) {
         // the type was a block, which set some parts of the qualifier
-        parseContext.mergeQualifiers(type.getQualifier(), qualifier);
+        _parseContext.mergeQualifiers(type.getQualifier(), qualifier);
     
         // merge in the attributes
-        parseContext.transferTypeAttributes(token.loc, attributes, type);
+        _parseContext.transferTypeAttributes(token.loc, attributes, type);
 
         // further, it can create an anonymous instance of the block
         // (cbuffer and tbuffer don't consume the next identifier, and
         // should set forbidDeclarators)
         if (forbidDeclarators || peek() != EHTokIdentifier)
-            parseContext.declareBlock(loc, type);
+            _parseContext.declareBlock(loc, type);
     } else {
         // Some qualifiers are set when parsing the type.  Merge those with
         // whatever comes from acceptQualifier.
@@ -651,7 +651,7 @@ bool HlslGrammar::acceptQualifier(TQualifier& qualifier)
     do {
         switch (peek()) {
         case EHTokStatic:
-            qualifier.storage = parseContext.symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
+            qualifier.storage = _parseContext.symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
             break;
         case EHTokExtern:
             // TODO: no meaning in glslang?
@@ -719,27 +719,27 @@ bool HlslGrammar::acceptQualifier(TQualifier& qualifier)
         // for output variables.
         case EHTokPoint:
             qualifier.storage = EvqIn;
-            if (!parseContext.handleInputGeometry(token.loc, ElgPoints))
+            if (!_parseContext.handleInputGeometry(token.loc, ElgPoints))
                 return false;
             break;
         case EHTokLine:
             qualifier.storage = EvqIn;
-            if (!parseContext.handleInputGeometry(token.loc, ElgLines))
+            if (!_parseContext.handleInputGeometry(token.loc, ElgLines))
                 return false;
             break;
         case EHTokTriangle:
             qualifier.storage = EvqIn;
-            if (!parseContext.handleInputGeometry(token.loc, ElgTriangles))
+            if (!_parseContext.handleInputGeometry(token.loc, ElgTriangles))
                 return false;
             break;
         case EHTokLineAdj:
             qualifier.storage = EvqIn;
-            if (!parseContext.handleInputGeometry(token.loc, ElgLinesAdjacency))
+            if (!_parseContext.handleInputGeometry(token.loc, ElgLinesAdjacency))
                 return false;
             break;
         case EHTokTriangleAdj:
             qualifier.storage = EvqIn;
-            if (!parseContext.handleInputGeometry(token.loc, ElgTrianglesAdjacency))
+            if (!_parseContext.handleInputGeometry(token.loc, ElgTrianglesAdjacency))
                 return false;
             break;
 
@@ -781,9 +781,9 @@ bool HlslGrammar::acceptLayoutQualifierList(TQualifier& qualifier)
                 expected("expression");
                 return false;
             }
-            parseContext.setLayoutQualifier(idToken.loc, qualifier, *idToken.string, expr);
+            _parseContext.setLayoutQualifier(idToken.loc, qualifier, *idToken.string, expr);
         } else
-            parseContext.setLayoutQualifier(idToken.loc, qualifier, *idToken.string);
+            _parseContext.setLayoutQualifier(idToken.loc, qualifier, *idToken.string);
 
         // COMMA
         if (! acceptTokenClass(EHTokComma))
@@ -1076,7 +1076,7 @@ bool HlslGrammar::acceptAnnotations(TQualifier&)
         return false;
 
     // note that we are nesting a name space
-    parseContext.nestAnnotations();
+    _parseContext.nestAnnotations();
 
     // declaration SEMI_COLON ... declaration SEMICOLON RIGHT_ANGLE
     do {
@@ -1095,7 +1095,7 @@ bool HlslGrammar::acceptAnnotations(TQualifier&)
         }
     } while (true);
 
-    parseContext.unnestAnnotations();
+    _parseContext.unnestAnnotations();
     return true;
 }
 
@@ -1154,7 +1154,7 @@ bool HlslGrammar::acceptSubpassInputType(TType& type)
     sampler.setSubpass(subpassBasicType, multisample);
 
     // Remember the declared return type.  Function returns false on error.
-    if (!parseContext.setTextureReturnType(sampler, subpassType, token.loc))
+    if (!_parseContext.setTextureReturnType(sampler, subpassType, token.loc))
         return false;
 
     type.shallowCopy(TType(sampler, EvqUniform));
@@ -1327,7 +1327,7 @@ bool HlslGrammar::acceptTextureType(TType& type)
 
     // Buffer, RWBuffer and RWTexture (images) require a TLayoutFormat.  We handle only a limit set.
     if (image || dim == EsdBuffer)
-        format = parseContext.getLayoutFromTxType(token.loc, txType);
+        format = _parseContext.getLayoutFromTxType(token.loc, txType);
 
     const TBasicType txBasicType = txType.isStruct() ? (*txType.getStruct())[0].type->getBasicType()
         : txType.getBasicType();
@@ -1345,7 +1345,7 @@ bool HlslGrammar::acceptTextureType(TType& type)
     }
 
     // Remember the declared return type.  Function returns false on error.
-    if (!parseContext.setTextureReturnType(sampler, txType, token.loc))
+    if (!_parseContext.setTextureReturnType(sampler, txType, token.loc))
         return false;
 
     // Force uncombined, if necessary
@@ -1369,7 +1369,7 @@ bool HlslGrammar::acceptType(TType& type)
 bool HlslGrammar::acceptType(TType& type, TIntermNode*& nodeList)
 {
     // Basic types for min* types, use native halfs if the option allows them.
-    bool enable16BitTypes = parseContext.hlslEnable16BitTypes();
+    bool enable16BitTypes = _parseContext.hlslEnable16BitTypes();
 
     const TBasicType min16float_bt = enable16BitTypes ? EbtFloat16 : EbtFloat;
     const TBasicType min10float_bt = enable16BitTypes ? EbtFloat16 : EbtFloat;
@@ -1385,7 +1385,7 @@ bool HlslGrammar::acceptType(TType& type, TIntermNode*& nodeList)
         if (identifierString != nullptr) {
             TString name = identifierString;
             // if it's an identifier, it's not a type
-            if (parseContext.symbolTable.find(name) != nullptr)
+            if (_parseContext.symbolTable.find(name) != nullptr)
                 return false;
         }
     }
@@ -1424,7 +1424,7 @@ bool HlslGrammar::acceptType(TType& type, TIntermNode*& nodeList)
             if (! acceptStreamOutTemplateType(type, geometry))
                 return false;
 
-            if (! parseContext.handleOutputGeometry(token.loc, geometry))
+            if (! _parseContext.handleOutputGeometry(token.loc, geometry))
                 return false;
 
             return true;
@@ -1499,7 +1499,7 @@ bool HlslGrammar::acceptType(TType& type, TIntermNode*& nodeList)
         // An identifier could be for a user-defined type.
         // Note we cache the symbol table lookup, to save for a later rule
         // when this is not a type.
-        if (parseContext.lookupUserType(*token.string, type) != nullptr) {
+        if (_parseContext.lookupUserType(*token.string, type) != nullptr) {
             advanceToken();
             return true;
         } else
@@ -2006,7 +2006,7 @@ bool HlslGrammar::acceptType(TType& type, TIntermNode*& nodeList)
     advanceToken();
 
     if ((isUnorm || isSnorm) && !type.isFloatingDomain()) {
-        parseContext.error(token.loc, "unorm and snorm only valid in floating point domain", "", "");
+        _parseContext.error(token.loc, "unorm and snorm only valid in floating point domain", "", "");
         return false;
     }
 
@@ -2068,7 +2068,7 @@ bool HlslGrammar::acceptStruct(TType& type, TIntermNode*& nodeList)
     // LEFT_BRACE, or
     // struct_type IDENTIFIER
     if (! acceptTokenClass(EHTokLeftBrace)) {
-        if (structName.size() > 0 && !postDeclsFound && parseContext.lookupUserType(structName, type) != nullptr) {
+        if (structName.size() > 0 && !postDeclsFound && _parseContext.lookupUserType(structName, type) != nullptr) {
             // struct_type IDENTIFIER
             return true;
         } else {
@@ -2083,9 +2083,9 @@ bool HlslGrammar::acceptStruct(TType& type, TIntermNode*& nodeList)
     // Save each member function so they can be processed after we have a fully formed 'this'.
     TVector<TFunctionDeclarator> functionDeclarators;
 
-    parseContext.pushNamespace(structName);
+    _parseContext.pushNamespace(structName);
     bool acceptedList = acceptStructDeclarationList(typeList, nodeList, functionDeclarators);
-    parseContext.popNamespace();
+    _parseContext.popNamespace();
 
     if (! acceptedList) {
         expected("struct member declarations");
@@ -2107,7 +2107,7 @@ bool HlslGrammar::acceptStruct(TType& type, TIntermNode*& nodeList)
         new(&type) TType(typeList, structName, postDeclQualifier); // sets EbtBlock
     }
 
-    parseContext.declareStruct(token.loc, structName, type);
+    _parseContext.declareStruct(token.loc, structName, type);
 
     // For member functions: now that we know the type of 'this', go back and
     // - add their implicit argument with 'this' (not to the mangling, just the argument list)
@@ -2120,8 +2120,8 @@ bool HlslGrammar::acceptStruct(TType& type, TIntermNode*& nodeList)
 
     // All member functions get parsed inside the class/struct namespace and with the
     // class/struct members in a symbol-table level.
-    parseContext.pushNamespace(structName);
-    parseContext.pushThisScope(type, functionDeclarators);
+    _parseContext.pushNamespace(structName);
+    _parseContext.pushThisScope(type, functionDeclarators);
     bool deferredSuccess = true;
     for (int b = 0; b < (int)functionDeclarators.size() && deferredSuccess; ++b) {
         // parse body
@@ -2130,8 +2130,8 @@ bool HlslGrammar::acceptStruct(TType& type, TIntermNode*& nodeList)
             deferredSuccess = false;
         popTokenStream();
     }
-    parseContext.popThisScope();
-    parseContext.popNamespace();
+    _parseContext.popThisScope();
+    _parseContext.popNamespace();
 
     return deferredSuccess;
 }
@@ -2172,7 +2172,7 @@ bool HlslGrammar::acceptConstantBufferType(TType& type)
 
         return true;
     } else {
-        parseContext.error(token.loc, "non-structure type in ConstantBuffer", "", "");
+        _parseContext.error(token.loc, "non-structure type in ConstantBuffer", "", "");
         return false;
     }
 }
@@ -2307,7 +2307,7 @@ bool HlslGrammar::acceptStructBufferType(TType& type)
 
     // We may have created an equivalent type before, in which case we should use its
     // deep structure.
-    parseContext.shareStructBufferType(blockType);
+    _parseContext.shareStructBufferType(blockType);
 
     type.shallowCopy(blockType);
 
@@ -2353,7 +2353,7 @@ bool HlslGrammar::acceptStructDeclarationList(TTypeList*& typeList, TIntermNode*
         }
         
         // merge in the attributes
-        parseContext.transferTypeAttributes(token.loc, attributes, memberType);
+        _parseContext.transferTypeAttributes(token.loc, attributes, memberType);
 
         // struct_declarator COMMA struct_declarator ...
         bool functionDefinitionAccepted = false;
@@ -2392,7 +2392,7 @@ bool HlslGrammar::acceptStructDeclarationList(TTypeList*& typeList, TIntermNode*
 
                 // EQUAL assignment_expression
                 if (acceptTokenClass(EHTokAssign)) {
-                    parseContext.warn(idToken.loc, "struct-member initializers ignored", "typedef", "");
+                    _parseContext.warn(idToken.loc, "struct-member initializers ignored", "typedef", "");
                     TIntermTyped* expressionNode = nullptr;
                     if (! acceptAssignmentExpression(expressionNode)) {
                         expected("initializer");
@@ -2436,7 +2436,7 @@ bool HlslGrammar::acceptMemberFunctionDefinition(TIntermNode*& nodeList, const T
     bool accepted = false;
 
     TString* functionName = &memberName;
-    parseContext.getFullNamespaceName(functionName);
+    _parseContext.getFullNamespaceName(functionName);
     declarator.function = new TFunction(functionName, type);
     if (type.getQualifier().storage == EvqTemporary)
         declarator.function->setImplicitThis();
@@ -2509,15 +2509,15 @@ bool HlslGrammar::acceptDefaultParameterDeclaration(const TType& type, TIntermTy
 
         // For initializer lists, we have to const-fold into a constructor for the type, so build
         // that.
-        TFunction* constructor = parseContext.makeConstructorCall(token.loc, type);
+        TFunction* constructor = _parseContext.makeConstructorCall(token.loc, type);
         if (constructor == nullptr)  // cannot construct
             return false;
 
         TIntermTyped* arguments = nullptr;
         for (int i = 0; i < int(node->getAsAggregate()->getSequence().size()); i++)
-            parseContext.handleFunctionArgument(constructor, arguments, node->getAsAggregate()->getSequence()[i]->getAsTyped());
+            _parseContext.handleFunctionArgument(constructor, arguments, node->getAsAggregate()->getSequence()[i]->getAsTyped());
 
-        node = parseContext.handleFunctionCall(token.loc, constructor, node);
+        node = _parseContext.handleFunctionCall(token.loc, constructor, node);
     }
 
     if (node == nullptr)
@@ -2535,7 +2535,7 @@ bool HlslGrammar::acceptDefaultParameterDeclaration(const TType& type, TIntermTy
     if (node != nullptr && origNode != node)
         return true;
 
-    parseContext.error(token.loc, "invalid default parameter value", "", "");
+    _parseContext.error(token.loc, "invalid default parameter value", "", "");
 
     return false;
 }
@@ -2559,7 +2559,7 @@ bool HlslGrammar::acceptParameterDeclaration(TFunction& function)
         return false;
 
     // merge in the attributes
-    parseContext.transferTypeAttributes(token.loc, attributes, *type);
+    _parseContext.transferTypeAttributes(token.loc, attributes, *type);
 
     // identifier
     HlslToken idToken;
@@ -2570,7 +2570,7 @@ bool HlslGrammar::acceptParameterDeclaration(TFunction& function)
     acceptArraySpecifier(arraySizes);
     if (arraySizes) {
         if (arraySizes->hasUnsized()) {
-            parseContext.error(token.loc, "function parameter requires array size", "[]", "");
+            _parseContext.error(token.loc, "function parameter requires array size", "[]", "");
             return false;
         }
 
@@ -2584,11 +2584,11 @@ bool HlslGrammar::acceptParameterDeclaration(TFunction& function)
     if (!acceptDefaultParameterDeclaration(*type, defaultValue))
         return false;
 
-    parseContext.paramFix(*type);
+    _parseContext.paramFix(*type);
 
     // If any prior parameters have default values, all the parameters after that must as well.
     if (defaultValue == nullptr && function.getDefaultParamCount() > 0) {
-        parseContext.error(idToken.loc, "invalid parameter after default value parameters", idToken.string->c_str(), "");
+        _parseContext.error(idToken.loc, "invalid parameter after default value parameters", idToken.string->c_str(), "");
         return false;
     }
 
@@ -2607,7 +2607,7 @@ bool HlslGrammar::acceptParameterDeclaration(TFunction& function)
 bool HlslGrammar::acceptFunctionDefinition(TFunctionDeclarator& declarator, TIntermNode*& nodeList,
                                            TVector<HlslToken>* deferredTokens)
 {
-    parseContext.handleFunctionDeclarator(declarator.loc, *declarator.function, false /* not prototype */);
+    _parseContext.handleFunctionDeclarator(declarator.loc, *declarator.function, false /* not prototype */);
 
     if (deferredTokens)
         return captureBlockTokens(*deferredTokens);
@@ -2621,7 +2621,7 @@ bool HlslGrammar::acceptFunctionBody(TFunctionDeclarator& declarator, TIntermNod
     TIntermNode* entryPointNode = nullptr;
 
     // This does a pushScope()
-    TIntermNode* functionNode = parseContext.handleFunctionDefinition(declarator.loc, *declarator.function,
+    TIntermNode* functionNode = _parseContext.handleFunctionDefinition(declarator.loc, *declarator.function,
                                                                       declarator.attributes, entryPointNode);
 
     // compound_statement
@@ -2630,7 +2630,7 @@ bool HlslGrammar::acceptFunctionBody(TFunctionDeclarator& declarator, TIntermNod
         return false;
 
     // this does a popScope()
-    parseContext.handleFunctionBody(declarator.loc, *declarator.function, functionBody, functionNode);
+    _parseContext.handleFunctionBody(declarator.loc, *declarator.function, functionBody, functionNode);
 
     // Hook up the 1 or 2 function definitions.
     nodeList = intermediate.growAggregate(nodeList, functionNode);
@@ -2817,11 +2817,11 @@ bool HlslGrammar::acceptAssignmentExpression(TIntermTyped*& node)
         return false;
     }
 
-    node = parseContext.handleAssign(loc, assignOp, node, rightNode);
-    node = parseContext.handleLvalue(loc, "assign", node);
+    node = _parseContext.handleAssign(loc, assignOp, node, rightNode);
+    node = _parseContext.handleLvalue(loc, "assign", node);
 
     if (node == nullptr) {
-        parseContext.error(loc, "could not create assignment", "", "");
+        _parseContext.error(loc, "could not create assignment", "", "");
         return false;
     }
 
@@ -2848,11 +2848,11 @@ bool HlslGrammar::acceptConditionalExpression(TIntermTyped*& node)
     if (! acceptTokenClass(EHTokQuestion))
         return true;
 
-    node = parseContext.convertConditionalExpression(token.loc, node, false);
+    node = _parseContext.convertConditionalExpression(token.loc, node, false);
     if (node == nullptr)
         return false;
 
-    ++parseContext.controlFlowNestingLevel;  // this only needs to work right if no errors
+    ++_parseContext.controlFlowNestingLevel;  // this only needs to work right if no errors
 
     TIntermTyped* trueNode = nullptr;
     if (! acceptExpression(trueNode)) {
@@ -2872,7 +2872,7 @@ bool HlslGrammar::acceptConditionalExpression(TIntermTyped*& node)
         return false;
     }
 
-    --parseContext.controlFlowNestingLevel;
+    --_parseContext.controlFlowNestingLevel;
 
     node = intermediate.addSelection(node, trueNode, falseNode, loc);
 
@@ -2917,7 +2917,7 @@ bool HlslGrammar::acceptBinaryExpression(TIntermTyped*& node, PrecedenceLevel pr
 
         node = intermediate.addBinaryMath(op, node, rightNode, loc);
         if (node == nullptr) {
-            parseContext.error(loc, "Could not perform requested binary operation", "", "");
+            _parseContext.error(loc, "Could not perform requested binary operation", "", "");
             return false;
         }
     } while (true);
@@ -2953,14 +2953,14 @@ bool HlslGrammar::acceptUnaryExpression(TIntermTyped*& node)
                     return false;
 
                 // Hook it up like a constructor
-                TFunction* constructorFunction = parseContext.makeConstructorCall(loc, castType);
+                TFunction* constructorFunction = _parseContext.makeConstructorCall(loc, castType);
                 if (constructorFunction == nullptr) {
                     expected("type that can be constructed");
                     return false;
                 }
                 TIntermTyped* arguments = nullptr;
-                parseContext.handleFunctionArgument(constructorFunction, arguments, node);
-                node = parseContext.handleFunctionCall(loc, constructorFunction, arguments);
+                _parseContext.handleFunctionArgument(constructorFunction, arguments, node);
+                node = _parseContext.handleFunctionCall(loc, constructorFunction, arguments);
 
                 return node != nullptr;
             } else {
@@ -2972,7 +2972,7 @@ bool HlslGrammar::acceptUnaryExpression(TIntermTyped*& node)
                 // Note, there are no array constructors like
                 //   (float[2](...))
                 if (arraySizes != nullptr)
-                    parseContext.error(loc, "parenthesized array constructor not allowed", "([]())", "", "");
+                    _parseContext.error(loc, "parenthesized array constructor not allowed", "([]())", "", "");
             }
         } else {
             // This isn't a type cast, but it still started "(", so if it is a
@@ -3004,7 +3004,7 @@ bool HlslGrammar::acceptUnaryExpression(TIntermTyped*& node)
 
     // These unary ops require lvalues
     if (unaryOp == EOpPreIncrement || unaryOp == EOpPreDecrement)
-        node = parseContext.handleLvalue(loc, "unary operator", node);
+        node = _parseContext.handleLvalue(loc, "unary operator", node);
 
     return node != nullptr;
 }
@@ -3052,7 +3052,7 @@ bool HlslGrammar::acceptPostfixExpression(TIntermTyped*& node)
         while (acceptTokenClass(EHTokColonColon)) {
             // user-type or namespace name
             fullName = NewPoolTString(fullName->c_str());
-            fullName->append(parseContext.scopeMangler);
+            fullName->append(_parseContext.scopeMangler);
             if (acceptIdentifier(idToken))
                 fullName->append(*idToken.string);
             else {
@@ -3061,7 +3061,7 @@ bool HlslGrammar::acceptPostfixExpression(TIntermTyped*& node)
             }
         }
         if (! peekTokenClass(EHTokLeftParen)) {
-            node = parseContext.handleVariable(idToken.loc, fullName);
+            node = _parseContext.handleVariable(idToken.loc, fullName);
             if (node == nullptr)
                 return false;
         } else if (acceptFunctionCall(idToken.loc, *fullName, node, nullptr)) {
@@ -3116,7 +3116,7 @@ bool HlslGrammar::acceptPostfixExpression(TIntermTyped*& node)
                     return false;
                 }
             } else
-                node = parseContext.handleDotDereference(field.loc, node, *field.string);
+                node = _parseContext.handleDotDereference(field.loc, node, *field.string);
 
             break;
         }
@@ -3130,7 +3130,7 @@ bool HlslGrammar::acceptPostfixExpression(TIntermTyped*& node)
                 return false;
             }
             advanceToken();
-            node = parseContext.handleBracketDereference(indexNode->getLoc(), node, indexNode);
+            node = _parseContext.handleBracketDereference(indexNode->getLoc(), node, indexNode);
             if (node == nullptr)
                 return false;
             break;
@@ -3141,7 +3141,7 @@ bool HlslGrammar::acceptPostfixExpression(TIntermTyped*& node)
         case EOpPostDecrement:
             // DEC_OP
             node = intermediate.addUnaryMath(postOp, node, loc);
-            node = parseContext.handleLvalue(loc, "unary operator", node);
+            node = _parseContext.handleLvalue(loc, "unary operator", node);
             break;
         default:
             assert(0);
@@ -3158,7 +3158,7 @@ bool HlslGrammar::acceptConstructor(TIntermTyped*& node)
     // type
     TType type;
     if (acceptType(type)) {
-        TFunction* constructorFunction = parseContext.makeConstructorCall(token.loc, type);
+        TFunction* constructorFunction = _parseContext.makeConstructorCall(token.loc, type);
         if (constructorFunction == nullptr)
             return false;
 
@@ -3172,7 +3172,7 @@ bool HlslGrammar::acceptConstructor(TIntermTyped*& node)
         }
 
         // hook it up
-        node = parseContext.handleFunctionCall(arguments->getLoc(), constructorFunction, arguments);
+        node = _parseContext.handleFunctionCall(arguments->getLoc(), constructorFunction, arguments);
 
         return node != nullptr;
     }
@@ -3191,7 +3191,7 @@ bool HlslGrammar::acceptFunctionCall(const TSourceLoc& loc, TString& name, TInte
     TString* functionName = nullptr;
     if (baseObject == nullptr) {
         functionName = &name;
-    } else if (parseContext.isBuiltInMethod(loc, baseObject, name)) {
+    } else if (_parseContext.isBuiltInMethod(loc, baseObject, name)) {
         // Built-in methods are not in the symbol table as methods, but as global functions
         // taking an explicit 'this' as the first argument.
         functionName = NewPoolTString(BUILTIN_PREFIX);
@@ -3203,7 +3203,7 @@ bool HlslGrammar::acceptFunctionCall(const TSourceLoc& loc, TString& name, TInte
         }
         functionName = NewPoolTString("");
         functionName->append(baseObject->getType().getTypeName());
-        parseContext.addScopeMangler(*functionName);
+        _parseContext.addScopeMangler(*functionName);
         functionName->append(name);
     }
 
@@ -3214,13 +3214,13 @@ bool HlslGrammar::acceptFunctionCall(const TSourceLoc& loc, TString& name, TInte
     TIntermTyped* arguments = nullptr;
     if (baseObject != nullptr) {
         // Non-static member functions have an implicit first argument of the base object.
-        parseContext.handleFunctionArgument(function, arguments, baseObject);
+        _parseContext.handleFunctionArgument(function, arguments, baseObject);
     }
     if (! acceptArguments(function, arguments))
         return false;
 
     // call
-    node = parseContext.handleFunctionCall(loc, function, arguments);
+    node = _parseContext.handleFunctionCall(loc, function, arguments);
 
     return node != nullptr;
 }
@@ -3249,7 +3249,7 @@ bool HlslGrammar::acceptArguments(TFunction* function, TIntermTyped*& arguments)
             return false;
 
         // hook it up
-        parseContext.handleFunctionArgument(function, arguments, arg);
+        _parseContext.handleFunctionArgument(function, arguments, arg);
 
         // COMMA
         if (! acceptTokenClass(EHTokComma))
@@ -3348,7 +3348,7 @@ bool HlslGrammar::acceptCompoundStatement(TIntermNode*& retStatement)
         if (branch != nullptr && (branch->getFlowOp() == EOpCase ||
                                   branch->getFlowOp() == EOpDefault)) {
             // hook up individual subsequences within a switch statement
-            parseContext.wrapupSwitchSubsequence(compoundStatement, statement);
+            _parseContext.wrapupSwitchSubsequence(compoundStatement, statement);
             compoundStatement = nullptr;
         } else {
             // hook it up to the growing compound statement
@@ -3366,18 +3366,18 @@ bool HlslGrammar::acceptCompoundStatement(TIntermNode*& retStatement)
 
 bool HlslGrammar::acceptScopedStatement(TIntermNode*& statement)
 {
-    parseContext.pushScope();
+    _parseContext.pushScope();
     bool result = acceptStatement(statement);
-    parseContext.popScope();
+    _parseContext.popScope();
 
     return result;
 }
 
 bool HlslGrammar::acceptScopedCompoundStatement(TIntermNode*& statement)
 {
-    parseContext.pushScope();
+    _parseContext.pushScope();
     bool result = acceptCompoundStatement(statement);
-    parseContext.popScope();
+    _parseContext.popScope();
 
     return result;
 }
@@ -3545,9 +3545,9 @@ void HlslGrammar::acceptAttributes(TAttributes& attributes)
 
         // Add any values we found into the attribute map.
         if (attributeToken.string != nullptr) {
-            TAttributeType attributeType = parseContext.attributeFromName(nameSpace, *attributeToken.string);
+            TAttributeType attributeType = _parseContext.attributeFromName(nameSpace, *attributeToken.string);
             if (attributeType == EatNone)
-                parseContext.warn(attributeToken.loc, "unrecognized attribute", attributeToken.string->c_str(), "");
+                _parseContext.warn(attributeToken.loc, "unrecognized attribute", attributeToken.string->c_str(), "");
             else {
                 TAttributeArgs attributeArgs = { attributeType, expressions };
                 attributes.push_back(attributeArgs);
@@ -3570,20 +3570,20 @@ bool HlslGrammar::acceptSelectionStatement(TIntermNode*& statement, const TAttri
 
     // so that something declared in the condition is scoped to the lifetimes
     // of the then-else statements
-    parseContext.pushScope();
+    _parseContext.pushScope();
 
     // LEFT_PAREN expression RIGHT_PAREN
     TIntermTyped* condition;
     if (! acceptParenExpression(condition))
         return false;
-    condition = parseContext.convertConditionalExpression(loc, condition);
+    condition = _parseContext.convertConditionalExpression(loc, condition);
     if (condition == nullptr)
         return false;
 
     // create the child statements
     TIntermNodePair thenElse = { nullptr, nullptr };
 
-    ++parseContext.controlFlowNestingLevel;  // this only needs to work right if no errors
+    ++_parseContext.controlFlowNestingLevel;  // this only needs to work right if no errors
 
     // then statement
     if (! acceptScopedStatement(thenElse.node1)) {
@@ -3602,10 +3602,10 @@ bool HlslGrammar::acceptSelectionStatement(TIntermNode*& statement, const TAttri
 
     // Put the pieces together
     statement = intermediate.addSelection(condition, thenElse, loc);
-    parseContext.handleSelectionAttributes(loc, statement->getAsSelectionNode(), attributes);
+    _parseContext.handleSelectionAttributes(loc, statement->getAsSelectionNode(), attributes);
 
-    parseContext.popScope();
-    --parseContext.controlFlowNestingLevel;
+    _parseContext.popScope();
+    --_parseContext.controlFlowNestingLevel;
 
     return true;
 }
@@ -3622,26 +3622,26 @@ bool HlslGrammar::acceptSwitchStatement(TIntermNode*& statement, const TAttribut
         return false;
 
     // LEFT_PAREN expression RIGHT_PAREN
-    parseContext.pushScope();
+    _parseContext.pushScope();
     TIntermTyped* switchExpression;
     if (! acceptParenExpression(switchExpression)) {
-        parseContext.popScope();
+        _parseContext.popScope();
         return false;
     }
 
     // compound_statement
-    parseContext.pushSwitchSequence(new TIntermSequence);
+    _parseContext.pushSwitchSequence(new TIntermSequence);
 
-    ++parseContext.controlFlowNestingLevel;
+    ++_parseContext.controlFlowNestingLevel;
     bool statementOkay = acceptCompoundStatement(statement);
-    --parseContext.controlFlowNestingLevel;
+    --_parseContext.controlFlowNestingLevel;
 
     if (statementOkay)
-        statement = parseContext.addSwitch(loc, switchExpression, statement ? statement->getAsAggregate() : nullptr,
+        statement = _parseContext.addSwitch(loc, switchExpression, statement ? statement->getAsAggregate() : nullptr,
                                            attributes);
 
-    parseContext.popSwitchSequence();
-    parseContext.popScope();
+    _parseContext.popSwitchSequence();
+    _parseContext.popScope();
 
     return statementOkay;
 }
@@ -3668,14 +3668,14 @@ bool HlslGrammar::acceptIterationStatement(TIntermNode*& statement, const TAttri
     case EHTokWhile:
         // so that something declared in the condition is scoped to the lifetime
         // of the while sub-statement
-        parseContext.pushScope();  // this only needs to work right if no errors
-        parseContext.nestLooping();
-        ++parseContext.controlFlowNestingLevel;
+        _parseContext.pushScope();  // this only needs to work right if no errors
+        _parseContext.nestLooping();
+        ++_parseContext.controlFlowNestingLevel;
 
         // LEFT_PAREN condition RIGHT_PAREN
         if (! acceptParenExpression(condition))
             return false;
-        condition = parseContext.convertConditionalExpression(loc, condition);
+        condition = _parseContext.convertConditionalExpression(loc, condition);
         if (condition == nullptr)
             return false;
 
@@ -3685,17 +3685,17 @@ bool HlslGrammar::acceptIterationStatement(TIntermNode*& statement, const TAttri
             return false;
         }
 
-        parseContext.unnestLooping();
-        parseContext.popScope();
-        --parseContext.controlFlowNestingLevel;
+        _parseContext.unnestLooping();
+        _parseContext.popScope();
+        --_parseContext.controlFlowNestingLevel;
 
         loopNode = intermediate.addLoop(statement, condition, nullptr, true, loc);
         statement = loopNode;
         break;
 
     case EHTokDo:
-        parseContext.nestLooping();  // this only needs to work right if no errors
-        ++parseContext.controlFlowNestingLevel;
+        _parseContext.nestLooping();  // this only needs to work right if no errors
+        ++_parseContext.controlFlowNestingLevel;
 
         // statement
         if (! acceptScopedStatement(statement)) {
@@ -3712,15 +3712,15 @@ bool HlslGrammar::acceptIterationStatement(TIntermNode*& statement, const TAttri
         // LEFT_PAREN condition RIGHT_PAREN
         if (! acceptParenExpression(condition))
             return false;
-        condition = parseContext.convertConditionalExpression(loc, condition);
+        condition = _parseContext.convertConditionalExpression(loc, condition);
         if (condition == nullptr)
             return false;
 
         if (! acceptTokenClass(EHTokSemicolon))
             expected(";");
 
-        parseContext.unnestLooping();
-        --parseContext.controlFlowNestingLevel;
+        _parseContext.unnestLooping();
+        --_parseContext.controlFlowNestingLevel;
 
         loopNode = intermediate.addLoop(statement, condition, 0, false, loc);
         statement = loopNode;
@@ -3734,22 +3734,22 @@ bool HlslGrammar::acceptIterationStatement(TIntermNode*& statement, const TAttri
 
         // so that something declared in the condition is scoped to the lifetime
         // of the for sub-statement
-        parseContext.pushScope();
+        _parseContext.pushScope();
 
         // initializer
         TIntermNode* initNode = nullptr;
         if (! acceptSimpleStatement(initNode))
             expected("for-loop initializer statement");
 
-        parseContext.nestLooping();  // this only needs to work right if no errors
-        ++parseContext.controlFlowNestingLevel;
+        _parseContext.nestLooping();  // this only needs to work right if no errors
+        ++_parseContext.controlFlowNestingLevel;
 
         // condition SEMI_COLON
         acceptExpression(condition);
         if (! acceptTokenClass(EHTokSemicolon))
             expected(";");
         if (condition != nullptr) {
-            condition = parseContext.convertConditionalExpression(loc, condition);
+            condition = _parseContext.convertConditionalExpression(loc, condition);
             if (condition == nullptr)
                 return false;
         }
@@ -3768,9 +3768,9 @@ bool HlslGrammar::acceptIterationStatement(TIntermNode*& statement, const TAttri
 
         statement = intermediate.addForLoop(statement, initNode, condition, iterator, true, loc, loopNode);
 
-        parseContext.popScope();
-        parseContext.unnestLooping();
-        --parseContext.controlFlowNestingLevel;
+        _parseContext.popScope();
+        _parseContext.unnestLooping();
+        --_parseContext.controlFlowNestingLevel;
 
         break;
     }
@@ -3779,7 +3779,7 @@ bool HlslGrammar::acceptIterationStatement(TIntermNode*& statement, const TAttri
         return false;
     }
 
-    parseContext.handleLoopAttributes(loc, loopNode, attributes);
+    _parseContext.handleLoopAttributes(loc, loopNode, attributes);
     return true;
 }
 
@@ -3808,14 +3808,14 @@ bool HlslGrammar::acceptJumpStatement(TIntermNode*& statement)
     switch (jump) {
     case EHTokContinue:
         statement = intermediate.addBranch(EOpContinue, token.loc);
-        if (parseContext.loopNestingLevel == 0) {
+        if (_parseContext.loopNestingLevel == 0) {
             expected("loop");
             return false;
         }
         break;
     case EHTokBreak:
         statement = intermediate.addBranch(EOpBreak, token.loc);
-        if (parseContext.loopNestingLevel == 0 && parseContext.switchSequenceStack.size() == 0) {
+        if (_parseContext.loopNestingLevel == 0 && _parseContext.switchSequenceStack.size() == 0) {
             expected("loop or switch");
             return false;
         }
@@ -3830,7 +3830,7 @@ bool HlslGrammar::acceptJumpStatement(TIntermNode*& statement)
         TIntermTyped* node;
         if (acceptExpression(node)) {
             // hook it up
-            statement = parseContext.handleReturnValue(token.loc, node);
+            statement = _parseContext.handleReturnValue(token.loc, node);
         } else
             statement = intermediate.addBranch(EOpReturn, token.loc);
         break;
@@ -3868,7 +3868,7 @@ bool HlslGrammar::acceptCaseLabel(TIntermNode*& statement)
         return false;
     }
 
-    statement = parseContext.intermediate.addBranch(EOpCase, expression, loc);
+    statement = _parseContext.intermediate.addBranch(EOpCase, expression, loc);
 
     return true;
 }
@@ -3887,7 +3887,7 @@ bool HlslGrammar::acceptDefaultLabel(TIntermNode*& statement)
         return false;
     }
 
-    statement = parseContext.intermediate.addBranch(EOpDefault, loc);
+    statement = _parseContext.intermediate.addBranch(EOpDefault, loc);
 
     return true;
 }
@@ -3922,7 +3922,7 @@ void HlslGrammar::acceptArraySpecifier(TArraySizes*& arraySizes)
 
         if (hasArraySize) {
             TArraySize arraySize;
-            parseContext.arraySizeCheck(loc, sizeExpr, arraySize);
+            _parseContext.arraySizeCheck(loc, sizeExpr, arraySize);
             arraySizes->addInnerSize(arraySize);
         } else {
             arraySizes->addInnerSize(0);  // sized by initializers.
@@ -3974,7 +3974,7 @@ bool HlslGrammar::acceptPostDecls(TQualifier& qualifier)
                     expected(")");
                     break;
                 }
-                parseContext.handlePackOffset(locationToken.loc, qualifier, *locationToken.string, componentToken.string);
+                _parseContext.handlePackOffset(locationToken.loc, qualifier, *locationToken.string, componentToken.string);
             } else if (! acceptIdentifier(idToken)) {
                 expected("layout, semantic, packoffset, or register");
                 return false;
@@ -4028,12 +4028,12 @@ bool HlslGrammar::acceptPostDecls(TQualifier& qualifier)
                     expected(")");
                     break;
                 }
-                parseContext.handleRegister(registerDesc.loc, qualifier, profile.string, *registerDesc.string, subComponent, spaceDesc.string);
+                _parseContext.handleRegister(registerDesc.loc, qualifier, profile.string, *registerDesc.string, subComponent, spaceDesc.string);
             } else {
                 // semantic, in idToken.string
                 TString semanticUpperCase = *idToken.string;
                 std::transform(semanticUpperCase.begin(), semanticUpperCase.end(), semanticUpperCase.begin(), ::toupper);
-                parseContext.handleSemantic(idToken.loc, qualifier, mapSemantic(semanticUpperCase.c_str()), semanticUpperCase);
+                _parseContext.handleSemantic(idToken.loc, qualifier, mapSemantic(semanticUpperCase.c_str()), semanticUpperCase);
             }
         } else if (peekTokenClass(EHTokLeftAngle)) {
             found = true;
diff --git a/deps/glslang/glslang/hlsl/hlslGrammar.h b/deps/glslang/glslang/hlsl/hlslGrammar.h
index 046f7957e5..f15ccca0cf 100755
--- a/deps/glslang/glslang/hlsl/hlslGrammar.h
+++ b/deps/glslang/glslang/hlsl/hlslGrammar.h
@@ -50,8 +50,8 @@ namespace glslang {
 
     class HlslGrammar : public HlslTokenStream {
     public:
-        HlslGrammar(HlslScanContext& scanner, HlslParseContext& parseContext)
-            : HlslTokenStream(scanner), parseContext(parseContext), intermediate(parseContext.intermediate),
+        HlslGrammar(HlslScanContext& scanner, HlslParseContext& _parseContext)
+            : HlslTokenStream(scanner), _parseContext(_parseContext), intermediate(_parseContext.intermediate),
               typeIdentifiers(false) { }
         virtual ~HlslGrammar() { }
 
@@ -130,7 +130,7 @@ namespace glslang {
         bool captureBlockTokens(TVector<HlslToken>& tokens);
         const char* getTypeString(EHlslTokenClass tokenClass) const;
 
-        HlslParseContext& parseContext;  // state of parsing and helper functions for building the intermediate
+        HlslParseContext& _parseContext;  // state of parsing and helper functions for building the intermediate
         TIntermediate& intermediate;     // the final product, the intermediate representation, includes the AST
         bool typeIdentifiers;            // shader uses some types as identifiers
     };
diff --git a/deps/glslang/glslang/hlsl/hlslScanContext.cpp b/deps/glslang/glslang/hlsl/hlslScanContext.cpp
index 28a66bb47d..4414eb7aa8 100755
--- a/deps/glslang/glslang/hlsl/hlslScanContext.cpp
+++ b/deps/glslang/glslang/hlsl/hlslScanContext.cpp
@@ -51,37 +51,15 @@
 // preprocessor includes
 #include "../glslang/MachineIndependent/preprocessor/PpContext.h"
 #include "../glslang/MachineIndependent/preprocessor/PpTokens.h"
+#include "../glslang/MachineIndependent/preprocessor/Compare.h"
 
 namespace {
 
-struct str_eq
-{
-    bool operator()(const char* lhs, const char* rhs) const
-    {
-        return strcmp(lhs, rhs) == 0;
-    }
-};
-
-struct str_hash
-{
-    size_t operator()(const char* str) const
-    {
-        // djb2
-        unsigned long hash = 5381;
-        int c;
-
-        while ((c = *str++) != 0)
-            hash = ((hash << 5) + hash) + c;
-
-        return hash;
-    }
-};
-
 // A single global usable by all threads, by all versions, by all languages.
 // After a single process-level initialization, this is read only and thread safe
-std::unordered_map<const char*, glslang::EHlslTokenClass, str_hash, str_eq>* KeywordMap = nullptr;
-std::unordered_set<const char*, str_hash, str_eq>* ReservedSet = nullptr;
-std::unordered_map<const char*, glslang::TBuiltInVariable, str_hash, str_eq>* SemanticMap = nullptr;
+std::unordered_map<const char*, glslang::EHlslTokenClass, str_hash, str_eq>* hlslKeywordMap = nullptr;
+std::unordered_set<const char*, str_hash, str_eq>* hlslReservedSet = nullptr;
+std::unordered_map<const char*, glslang::TBuiltInVariable, str_hash, str_eq>* hlslSemanticMap = nullptr;
 
 };
 
@@ -89,323 +67,323 @@ namespace glslang {
 
 void HlslScanContext::fillInKeywordMap()
 {
-    if (KeywordMap != nullptr) {
+    if (hlslKeywordMap != nullptr) {
         // this is really an error, as this should called only once per process
         // but, the only risk is if two threads called simultaneously
         return;
     }
-    KeywordMap = new std::unordered_map<const char*, EHlslTokenClass, str_hash, str_eq>;
-
-    (*KeywordMap)["static"] =                  EHTokStatic;
-    (*KeywordMap)["const"] =                   EHTokConst;
-    (*KeywordMap)["unorm"] =                   EHTokUnorm;
-    (*KeywordMap)["snorm"] =                   EHTokSNorm;
-    (*KeywordMap)["extern"] =                  EHTokExtern;
-    (*KeywordMap)["uniform"] =                 EHTokUniform;
-    (*KeywordMap)["volatile"] =                EHTokVolatile;
-    (*KeywordMap)["precise"] =                 EHTokPrecise;
-    (*KeywordMap)["shared"] =                  EHTokShared;
-    (*KeywordMap)["groupshared"] =             EHTokGroupShared;
-    (*KeywordMap)["linear"] =                  EHTokLinear;
-    (*KeywordMap)["centroid"] =                EHTokCentroid;
-    (*KeywordMap)["nointerpolation"] =         EHTokNointerpolation;
-    (*KeywordMap)["noperspective"] =           EHTokNoperspective;
-    (*KeywordMap)["sample"] =                  EHTokSample;
-    (*KeywordMap)["row_major"] =               EHTokRowMajor;
-    (*KeywordMap)["column_major"] =            EHTokColumnMajor;
-    (*KeywordMap)["packoffset"] =              EHTokPackOffset;
-    (*KeywordMap)["in"] =                      EHTokIn;
-    (*KeywordMap)["out"] =                     EHTokOut;
-    (*KeywordMap)["inout"] =                   EHTokInOut;
-    (*KeywordMap)["layout"] =                  EHTokLayout;
-    (*KeywordMap)["globallycoherent"] =        EHTokGloballyCoherent;
-    (*KeywordMap)["inline"] =                  EHTokInline;
-
-    (*KeywordMap)["point"] =                   EHTokPoint;
-    (*KeywordMap)["line"] =                    EHTokLine;
-    (*KeywordMap)["triangle"] =                EHTokTriangle;
-    (*KeywordMap)["lineadj"] =                 EHTokLineAdj;
-    (*KeywordMap)["triangleadj"] =             EHTokTriangleAdj;
-
-    (*KeywordMap)["PointStream"] =             EHTokPointStream;
-    (*KeywordMap)["LineStream"] =              EHTokLineStream;
-    (*KeywordMap)["TriangleStream"] =          EHTokTriangleStream;
-
-    (*KeywordMap)["InputPatch"] =              EHTokInputPatch;
-    (*KeywordMap)["OutputPatch"] =             EHTokOutputPatch;
-
-    (*KeywordMap)["Buffer"] =                  EHTokBuffer;
-    (*KeywordMap)["vector"] =                  EHTokVector;
-    (*KeywordMap)["matrix"] =                  EHTokMatrix;
-
-    (*KeywordMap)["void"] =                    EHTokVoid;
-    (*KeywordMap)["string"] =                  EHTokString;
-    (*KeywordMap)["bool"] =                    EHTokBool;
-    (*KeywordMap)["int"] =                     EHTokInt;
-    (*KeywordMap)["uint"] =                    EHTokUint;
-    (*KeywordMap)["uint64_t"] =                EHTokUint64;
-    (*KeywordMap)["dword"] =                   EHTokDword;
-    (*KeywordMap)["half"] =                    EHTokHalf;
-    (*KeywordMap)["float"] =                   EHTokFloat;
-    (*KeywordMap)["double"] =                  EHTokDouble;
-    (*KeywordMap)["min16float"] =              EHTokMin16float;
-    (*KeywordMap)["min10float"] =              EHTokMin10float;
-    (*KeywordMap)["min16int"] =                EHTokMin16int;
-    (*KeywordMap)["min12int"] =                EHTokMin12int;
-    (*KeywordMap)["min16uint"] =               EHTokMin16uint;
-
-    (*KeywordMap)["bool1"] =                   EHTokBool1;
-    (*KeywordMap)["bool2"] =                   EHTokBool2;
-    (*KeywordMap)["bool3"] =                   EHTokBool3;
-    (*KeywordMap)["bool4"] =                   EHTokBool4;
-    (*KeywordMap)["float1"] =                  EHTokFloat1;
-    (*KeywordMap)["float2"] =                  EHTokFloat2;
-    (*KeywordMap)["float3"] =                  EHTokFloat3;
-    (*KeywordMap)["float4"] =                  EHTokFloat4;
-    (*KeywordMap)["int1"] =                    EHTokInt1;
-    (*KeywordMap)["int2"] =                    EHTokInt2;
-    (*KeywordMap)["int3"] =                    EHTokInt3;
-    (*KeywordMap)["int4"] =                    EHTokInt4;
-    (*KeywordMap)["double1"] =                 EHTokDouble1;
-    (*KeywordMap)["double2"] =                 EHTokDouble2;
-    (*KeywordMap)["double3"] =                 EHTokDouble3;
-    (*KeywordMap)["double4"] =                 EHTokDouble4;
-    (*KeywordMap)["uint1"] =                   EHTokUint1;
-    (*KeywordMap)["uint2"] =                   EHTokUint2;
-    (*KeywordMap)["uint3"] =                   EHTokUint3;
-    (*KeywordMap)["uint4"] =                   EHTokUint4;
-
-    (*KeywordMap)["half1"] =                   EHTokHalf1;
-    (*KeywordMap)["half2"] =                   EHTokHalf2;
-    (*KeywordMap)["half3"] =                   EHTokHalf3;
-    (*KeywordMap)["half4"] =                   EHTokHalf4;
-    (*KeywordMap)["min16float1"] =             EHTokMin16float1;
-    (*KeywordMap)["min16float2"] =             EHTokMin16float2;
-    (*KeywordMap)["min16float3"] =             EHTokMin16float3;
-    (*KeywordMap)["min16float4"] =             EHTokMin16float4;
-    (*KeywordMap)["min10float1"] =             EHTokMin10float1;
-    (*KeywordMap)["min10float2"] =             EHTokMin10float2;
-    (*KeywordMap)["min10float3"] =             EHTokMin10float3;
-    (*KeywordMap)["min10float4"] =             EHTokMin10float4;
-    (*KeywordMap)["min16int1"] =               EHTokMin16int1;
-    (*KeywordMap)["min16int2"] =               EHTokMin16int2;
-    (*KeywordMap)["min16int3"] =               EHTokMin16int3;
-    (*KeywordMap)["min16int4"] =               EHTokMin16int4;
-    (*KeywordMap)["min12int1"] =               EHTokMin12int1;
-    (*KeywordMap)["min12int2"] =               EHTokMin12int2;
-    (*KeywordMap)["min12int3"] =               EHTokMin12int3;
-    (*KeywordMap)["min12int4"] =               EHTokMin12int4;
-    (*KeywordMap)["min16uint1"] =              EHTokMin16uint1;
-    (*KeywordMap)["min16uint2"] =              EHTokMin16uint2;
-    (*KeywordMap)["min16uint3"] =              EHTokMin16uint3;
-    (*KeywordMap)["min16uint4"] =              EHTokMin16uint4;
-
-    (*KeywordMap)["bool1x1"] =                 EHTokBool1x1;
-    (*KeywordMap)["bool1x2"] =                 EHTokBool1x2;
-    (*KeywordMap)["bool1x3"] =                 EHTokBool1x3;
-    (*KeywordMap)["bool1x4"] =                 EHTokBool1x4;
-    (*KeywordMap)["bool2x1"] =                 EHTokBool2x1;
-    (*KeywordMap)["bool2x2"] =                 EHTokBool2x2;
-    (*KeywordMap)["bool2x3"] =                 EHTokBool2x3;
-    (*KeywordMap)["bool2x4"] =                 EHTokBool2x4;
-    (*KeywordMap)["bool3x1"] =                 EHTokBool3x1;
-    (*KeywordMap)["bool3x2"] =                 EHTokBool3x2;
-    (*KeywordMap)["bool3x3"] =                 EHTokBool3x3;
-    (*KeywordMap)["bool3x4"] =                 EHTokBool3x4;
-    (*KeywordMap)["bool4x1"] =                 EHTokBool4x1;
-    (*KeywordMap)["bool4x2"] =                 EHTokBool4x2;
-    (*KeywordMap)["bool4x3"] =                 EHTokBool4x3;
-    (*KeywordMap)["bool4x4"] =                 EHTokBool4x4;
-    (*KeywordMap)["int1x1"] =                  EHTokInt1x1;
-    (*KeywordMap)["int1x2"] =                  EHTokInt1x2;
-    (*KeywordMap)["int1x3"] =                  EHTokInt1x3;
-    (*KeywordMap)["int1x4"] =                  EHTokInt1x4;
-    (*KeywordMap)["int2x1"] =                  EHTokInt2x1;
-    (*KeywordMap)["int2x2"] =                  EHTokInt2x2;
-    (*KeywordMap)["int2x3"] =                  EHTokInt2x3;
-    (*KeywordMap)["int2x4"] =                  EHTokInt2x4;
-    (*KeywordMap)["int3x1"] =                  EHTokInt3x1;
-    (*KeywordMap)["int3x2"] =                  EHTokInt3x2;
-    (*KeywordMap)["int3x3"] =                  EHTokInt3x3;
-    (*KeywordMap)["int3x4"] =                  EHTokInt3x4;
-    (*KeywordMap)["int4x1"] =                  EHTokInt4x1;
-    (*KeywordMap)["int4x2"] =                  EHTokInt4x2;
-    (*KeywordMap)["int4x3"] =                  EHTokInt4x3;
-    (*KeywordMap)["int4x4"] =                  EHTokInt4x4;
-    (*KeywordMap)["uint1x1"] =                 EHTokUint1x1;
-    (*KeywordMap)["uint1x2"] =                 EHTokUint1x2;
-    (*KeywordMap)["uint1x3"] =                 EHTokUint1x3;
-    (*KeywordMap)["uint1x4"] =                 EHTokUint1x4;
-    (*KeywordMap)["uint2x1"] =                 EHTokUint2x1;
-    (*KeywordMap)["uint2x2"] =                 EHTokUint2x2;
-    (*KeywordMap)["uint2x3"] =                 EHTokUint2x3;
-    (*KeywordMap)["uint2x4"] =                 EHTokUint2x4;
-    (*KeywordMap)["uint3x1"] =                 EHTokUint3x1;
-    (*KeywordMap)["uint3x2"] =                 EHTokUint3x2;
-    (*KeywordMap)["uint3x3"] =                 EHTokUint3x3;
-    (*KeywordMap)["uint3x4"] =                 EHTokUint3x4;
-    (*KeywordMap)["uint4x1"] =                 EHTokUint4x1;
-    (*KeywordMap)["uint4x2"] =                 EHTokUint4x2;
-    (*KeywordMap)["uint4x3"] =                 EHTokUint4x3;
-    (*KeywordMap)["uint4x4"] =                 EHTokUint4x4;
-    (*KeywordMap)["bool1x1"] =                 EHTokBool1x1;
-    (*KeywordMap)["bool1x2"] =                 EHTokBool1x2;
-    (*KeywordMap)["bool1x3"] =                 EHTokBool1x3;
-    (*KeywordMap)["bool1x4"] =                 EHTokBool1x4;
-    (*KeywordMap)["bool2x1"] =                 EHTokBool2x1;
-    (*KeywordMap)["bool2x2"] =                 EHTokBool2x2;
-    (*KeywordMap)["bool2x3"] =                 EHTokBool2x3;
-    (*KeywordMap)["bool2x4"] =                 EHTokBool2x4;
-    (*KeywordMap)["bool3x1"] =                 EHTokBool3x1;
-    (*KeywordMap)["bool3x2"] =                 EHTokBool3x2;
-    (*KeywordMap)["bool3x3"] =                 EHTokBool3x3;
-    (*KeywordMap)["bool3x4"] =                 EHTokBool3x4;
-    (*KeywordMap)["bool4x1"] =                 EHTokBool4x1;
-    (*KeywordMap)["bool4x2"] =                 EHTokBool4x2;
-    (*KeywordMap)["bool4x3"] =                 EHTokBool4x3;
-    (*KeywordMap)["bool4x4"] =                 EHTokBool4x4;
-    (*KeywordMap)["float1x1"] =                EHTokFloat1x1;
-    (*KeywordMap)["float1x2"] =                EHTokFloat1x2;
-    (*KeywordMap)["float1x3"] =                EHTokFloat1x3;
-    (*KeywordMap)["float1x4"] =                EHTokFloat1x4;
-    (*KeywordMap)["float2x1"] =                EHTokFloat2x1;
-    (*KeywordMap)["float2x2"] =                EHTokFloat2x2;
-    (*KeywordMap)["float2x3"] =                EHTokFloat2x3;
-    (*KeywordMap)["float2x4"] =                EHTokFloat2x4;
-    (*KeywordMap)["float3x1"] =                EHTokFloat3x1;
-    (*KeywordMap)["float3x2"] =                EHTokFloat3x2;
-    (*KeywordMap)["float3x3"] =                EHTokFloat3x3;
-    (*KeywordMap)["float3x4"] =                EHTokFloat3x4;
-    (*KeywordMap)["float4x1"] =                EHTokFloat4x1;
-    (*KeywordMap)["float4x2"] =                EHTokFloat4x2;
-    (*KeywordMap)["float4x3"] =                EHTokFloat4x3;
-    (*KeywordMap)["float4x4"] =                EHTokFloat4x4;
-    (*KeywordMap)["half1x1"] =                 EHTokHalf1x1;
-    (*KeywordMap)["half1x2"] =                 EHTokHalf1x2;
-    (*KeywordMap)["half1x3"] =                 EHTokHalf1x3;
-    (*KeywordMap)["half1x4"] =                 EHTokHalf1x4;
-    (*KeywordMap)["half2x1"] =                 EHTokHalf2x1;
-    (*KeywordMap)["half2x2"] =                 EHTokHalf2x2;
-    (*KeywordMap)["half2x3"] =                 EHTokHalf2x3;
-    (*KeywordMap)["half2x4"] =                 EHTokHalf2x4;
-    (*KeywordMap)["half3x1"] =                 EHTokHalf3x1;
-    (*KeywordMap)["half3x2"] =                 EHTokHalf3x2;
-    (*KeywordMap)["half3x3"] =                 EHTokHalf3x3;
-    (*KeywordMap)["half3x4"] =                 EHTokHalf3x4;
-    (*KeywordMap)["half4x1"] =                 EHTokHalf4x1;
-    (*KeywordMap)["half4x2"] =                 EHTokHalf4x2;
-    (*KeywordMap)["half4x3"] =                 EHTokHalf4x3;
-    (*KeywordMap)["half4x4"] =                 EHTokHalf4x4;
-    (*KeywordMap)["double1x1"] =               EHTokDouble1x1;
-    (*KeywordMap)["double1x2"] =               EHTokDouble1x2;
-    (*KeywordMap)["double1x3"] =               EHTokDouble1x3;
-    (*KeywordMap)["double1x4"] =               EHTokDouble1x4;
-    (*KeywordMap)["double2x1"] =               EHTokDouble2x1;
-    (*KeywordMap)["double2x2"] =               EHTokDouble2x2;
-    (*KeywordMap)["double2x3"] =               EHTokDouble2x3;
-    (*KeywordMap)["double2x4"] =               EHTokDouble2x4;
-    (*KeywordMap)["double3x1"] =               EHTokDouble3x1;
-    (*KeywordMap)["double3x2"] =               EHTokDouble3x2;
-    (*KeywordMap)["double3x3"] =               EHTokDouble3x3;
-    (*KeywordMap)["double3x4"] =               EHTokDouble3x4;
-    (*KeywordMap)["double4x1"] =               EHTokDouble4x1;
-    (*KeywordMap)["double4x2"] =               EHTokDouble4x2;
-    (*KeywordMap)["double4x3"] =               EHTokDouble4x3;
-    (*KeywordMap)["double4x4"] =               EHTokDouble4x4;
-
-    (*KeywordMap)["sampler"] =                 EHTokSampler;
-    (*KeywordMap)["sampler1D"] =               EHTokSampler1d;
-    (*KeywordMap)["sampler2D"] =               EHTokSampler2d;
-    (*KeywordMap)["sampler3D"] =               EHTokSampler3d;
-    (*KeywordMap)["samplerCube"] =             EHTokSamplerCube;
-    (*KeywordMap)["sampler_state"] =           EHTokSamplerState;
-    (*KeywordMap)["SamplerState"] =            EHTokSamplerState;
-    (*KeywordMap)["SamplerComparisonState"] =  EHTokSamplerComparisonState;
-    (*KeywordMap)["texture"] =                 EHTokTexture;
-    (*KeywordMap)["Texture1D"] =               EHTokTexture1d;
-    (*KeywordMap)["Texture1DArray"] =          EHTokTexture1darray;
-    (*KeywordMap)["Texture2D"] =               EHTokTexture2d;
-    (*KeywordMap)["Texture2DArray"] =          EHTokTexture2darray;
-    (*KeywordMap)["Texture3D"] =               EHTokTexture3d;
-    (*KeywordMap)["TextureCube"] =             EHTokTextureCube;
-    (*KeywordMap)["TextureCubeArray"] =        EHTokTextureCubearray;
-    (*KeywordMap)["Texture2DMS"] =             EHTokTexture2DMS;
-    (*KeywordMap)["Texture2DMSArray"] =        EHTokTexture2DMSarray;
-    (*KeywordMap)["RWTexture1D"] =             EHTokRWTexture1d;
-    (*KeywordMap)["RWTexture1DArray"] =        EHTokRWTexture1darray;
-    (*KeywordMap)["RWTexture2D"] =             EHTokRWTexture2d;
-    (*KeywordMap)["RWTexture2DArray"] =        EHTokRWTexture2darray;
-    (*KeywordMap)["RWTexture3D"] =             EHTokRWTexture3d;
-    (*KeywordMap)["RWBuffer"] =                EHTokRWBuffer;
-    (*KeywordMap)["SubpassInput"] =            EHTokSubpassInput;
-    (*KeywordMap)["SubpassInputMS"] =          EHTokSubpassInputMS;
-
-    (*KeywordMap)["AppendStructuredBuffer"] =  EHTokAppendStructuredBuffer;
-    (*KeywordMap)["ByteAddressBuffer"] =       EHTokByteAddressBuffer;
-    (*KeywordMap)["ConsumeStructuredBuffer"] = EHTokConsumeStructuredBuffer;
-    (*KeywordMap)["RWByteAddressBuffer"] =     EHTokRWByteAddressBuffer;
-    (*KeywordMap)["RWStructuredBuffer"] =      EHTokRWStructuredBuffer;
-    (*KeywordMap)["StructuredBuffer"] =        EHTokStructuredBuffer;
-    (*KeywordMap)["TextureBuffer"] =           EHTokTextureBuffer;
-
-    (*KeywordMap)["class"] =                   EHTokClass;
-    (*KeywordMap)["struct"] =                  EHTokStruct;
-    (*KeywordMap)["cbuffer"] =                 EHTokCBuffer;
-    (*KeywordMap)["ConstantBuffer"] =          EHTokConstantBuffer;
-    (*KeywordMap)["tbuffer"] =                 EHTokTBuffer;
-    (*KeywordMap)["typedef"] =                 EHTokTypedef;
-    (*KeywordMap)["this"] =                    EHTokThis;
-    (*KeywordMap)["namespace"] =               EHTokNamespace;
-
-    (*KeywordMap)["true"] =                    EHTokBoolConstant;
-    (*KeywordMap)["false"] =                   EHTokBoolConstant;
-
-    (*KeywordMap)["for"] =                     EHTokFor;
-    (*KeywordMap)["do"] =                      EHTokDo;
-    (*KeywordMap)["while"] =                   EHTokWhile;
-    (*KeywordMap)["break"] =                   EHTokBreak;
-    (*KeywordMap)["continue"] =                EHTokContinue;
-    (*KeywordMap)["if"] =                      EHTokIf;
-    (*KeywordMap)["else"] =                    EHTokElse;
-    (*KeywordMap)["discard"] =                 EHTokDiscard;
-    (*KeywordMap)["return"] =                  EHTokReturn;
-    (*KeywordMap)["switch"] =                  EHTokSwitch;
-    (*KeywordMap)["case"] =                    EHTokCase;
-    (*KeywordMap)["default"] =                 EHTokDefault;
+    hlslKeywordMap = new std::unordered_map<const char*, EHlslTokenClass, str_hash, str_eq>;
+
+    (*hlslKeywordMap)["static"] =                  EHTokStatic;
+    (*hlslKeywordMap)["const"] =                   EHTokConst;
+    (*hlslKeywordMap)["unorm"] =                   EHTokUnorm;
+    (*hlslKeywordMap)["snorm"] =                   EHTokSNorm;
+    (*hlslKeywordMap)["extern"] =                  EHTokExtern;
+    (*hlslKeywordMap)["uniform"] =                 EHTokUniform;
+    (*hlslKeywordMap)["volatile"] =                EHTokVolatile;
+    (*hlslKeywordMap)["precise"] =                 EHTokPrecise;
+    (*hlslKeywordMap)["shared"] =                  EHTokShared;
+    (*hlslKeywordMap)["groupshared"] =             EHTokGroupShared;
+    (*hlslKeywordMap)["linear"] =                  EHTokLinear;
+    (*hlslKeywordMap)["centroid"] =                EHTokCentroid;
+    (*hlslKeywordMap)["nointerpolation"] =         EHTokNointerpolation;
+    (*hlslKeywordMap)["noperspective"] =           EHTokNoperspective;
+    (*hlslKeywordMap)["sample"] =                  EHTokSample;
+    (*hlslKeywordMap)["row_major"] =               EHTokRowMajor;
+    (*hlslKeywordMap)["column_major"] =            EHTokColumnMajor;
+    (*hlslKeywordMap)["packoffset"] =              EHTokPackOffset;
+    (*hlslKeywordMap)["in"] =                      EHTokIn;
+    (*hlslKeywordMap)["out"] =                     EHTokOut;
+    (*hlslKeywordMap)["inout"] =                   EHTokInOut;
+    (*hlslKeywordMap)["layout"] =                  EHTokLayout;
+    (*hlslKeywordMap)["globallycoherent"] =        EHTokGloballyCoherent;
+    (*hlslKeywordMap)["inline"] =                  EHTokInline;
+
+    (*hlslKeywordMap)["point"] =                   EHTokPoint;
+    (*hlslKeywordMap)["line"] =                    EHTokLine;
+    (*hlslKeywordMap)["triangle"] =                EHTokTriangle;
+    (*hlslKeywordMap)["lineadj"] =                 EHTokLineAdj;
+    (*hlslKeywordMap)["triangleadj"] =             EHTokTriangleAdj;
+
+    (*hlslKeywordMap)["PointStream"] =             EHTokPointStream;
+    (*hlslKeywordMap)["LineStream"] =              EHTokLineStream;
+    (*hlslKeywordMap)["TriangleStream"] =          EHTokTriangleStream;
+
+    (*hlslKeywordMap)["InputPatch"] =              EHTokInputPatch;
+    (*hlslKeywordMap)["OutputPatch"] =             EHTokOutputPatch;
+
+    (*hlslKeywordMap)["Buffer"] =                  EHTokBuffer;
+    (*hlslKeywordMap)["vector"] =                  EHTokVector;
+    (*hlslKeywordMap)["matrix"] =                  EHTokMatrix;
+
+    (*hlslKeywordMap)["void"] =                    EHTokVoid;
+    (*hlslKeywordMap)["string"] =                  EHTokString;
+    (*hlslKeywordMap)["bool"] =                    EHTokBool;
+    (*hlslKeywordMap)["int"] =                     EHTokInt;
+    (*hlslKeywordMap)["uint"] =                    EHTokUint;
+    (*hlslKeywordMap)["uint64_t"] =                EHTokUint64;
+    (*hlslKeywordMap)["dword"] =                   EHTokDword;
+    (*hlslKeywordMap)["half"] =                    EHTokHalf;
+    (*hlslKeywordMap)["float"] =                   EHTokFloat;
+    (*hlslKeywordMap)["double"] =                  EHTokDouble;
+    (*hlslKeywordMap)["min16float"] =              EHTokMin16float;
+    (*hlslKeywordMap)["min10float"] =              EHTokMin10float;
+    (*hlslKeywordMap)["min16int"] =                EHTokMin16int;
+    (*hlslKeywordMap)["min12int"] =                EHTokMin12int;
+    (*hlslKeywordMap)["min16uint"] =               EHTokMin16uint;
+
+    (*hlslKeywordMap)["bool1"] =                   EHTokBool1;
+    (*hlslKeywordMap)["bool2"] =                   EHTokBool2;
+    (*hlslKeywordMap)["bool3"] =                   EHTokBool3;
+    (*hlslKeywordMap)["bool4"] =                   EHTokBool4;
+    (*hlslKeywordMap)["float1"] =                  EHTokFloat1;
+    (*hlslKeywordMap)["float2"] =                  EHTokFloat2;
+    (*hlslKeywordMap)["float3"] =                  EHTokFloat3;
+    (*hlslKeywordMap)["float4"] =                  EHTokFloat4;
+    (*hlslKeywordMap)["int1"] =                    EHTokInt1;
+    (*hlslKeywordMap)["int2"] =                    EHTokInt2;
+    (*hlslKeywordMap)["int3"] =                    EHTokInt3;
+    (*hlslKeywordMap)["int4"] =                    EHTokInt4;
+    (*hlslKeywordMap)["double1"] =                 EHTokDouble1;
+    (*hlslKeywordMap)["double2"] =                 EHTokDouble2;
+    (*hlslKeywordMap)["double3"] =                 EHTokDouble3;
+    (*hlslKeywordMap)["double4"] =                 EHTokDouble4;
+    (*hlslKeywordMap)["uint1"] =                   EHTokUint1;
+    (*hlslKeywordMap)["uint2"] =                   EHTokUint2;
+    (*hlslKeywordMap)["uint3"] =                   EHTokUint3;
+    (*hlslKeywordMap)["uint4"] =                   EHTokUint4;
+
+    (*hlslKeywordMap)["half1"] =                   EHTokHalf1;
+    (*hlslKeywordMap)["half2"] =                   EHTokHalf2;
+    (*hlslKeywordMap)["half3"] =                   EHTokHalf3;
+    (*hlslKeywordMap)["half4"] =                   EHTokHalf4;
+    (*hlslKeywordMap)["min16float1"] =             EHTokMin16float1;
+    (*hlslKeywordMap)["min16float2"] =             EHTokMin16float2;
+    (*hlslKeywordMap)["min16float3"] =             EHTokMin16float3;
+    (*hlslKeywordMap)["min16float4"] =             EHTokMin16float4;
+    (*hlslKeywordMap)["min10float1"] =             EHTokMin10float1;
+    (*hlslKeywordMap)["min10float2"] =             EHTokMin10float2;
+    (*hlslKeywordMap)["min10float3"] =             EHTokMin10float3;
+    (*hlslKeywordMap)["min10float4"] =             EHTokMin10float4;
+    (*hlslKeywordMap)["min16int1"] =               EHTokMin16int1;
+    (*hlslKeywordMap)["min16int2"] =               EHTokMin16int2;
+    (*hlslKeywordMap)["min16int3"] =               EHTokMin16int3;
+    (*hlslKeywordMap)["min16int4"] =               EHTokMin16int4;
+    (*hlslKeywordMap)["min12int1"] =               EHTokMin12int1;
+    (*hlslKeywordMap)["min12int2"] =               EHTokMin12int2;
+    (*hlslKeywordMap)["min12int3"] =               EHTokMin12int3;
+    (*hlslKeywordMap)["min12int4"] =               EHTokMin12int4;
+    (*hlslKeywordMap)["min16uint1"] =              EHTokMin16uint1;
+    (*hlslKeywordMap)["min16uint2"] =              EHTokMin16uint2;
+    (*hlslKeywordMap)["min16uint3"] =              EHTokMin16uint3;
+    (*hlslKeywordMap)["min16uint4"] =              EHTokMin16uint4;
+
+    (*hlslKeywordMap)["bool1x1"] =                 EHTokBool1x1;
+    (*hlslKeywordMap)["bool1x2"] =                 EHTokBool1x2;
+    (*hlslKeywordMap)["bool1x3"] =                 EHTokBool1x3;
+    (*hlslKeywordMap)["bool1x4"] =                 EHTokBool1x4;
+    (*hlslKeywordMap)["bool2x1"] =                 EHTokBool2x1;
+    (*hlslKeywordMap)["bool2x2"] =                 EHTokBool2x2;
+    (*hlslKeywordMap)["bool2x3"] =                 EHTokBool2x3;
+    (*hlslKeywordMap)["bool2x4"] =                 EHTokBool2x4;
+    (*hlslKeywordMap)["bool3x1"] =                 EHTokBool3x1;
+    (*hlslKeywordMap)["bool3x2"] =                 EHTokBool3x2;
+    (*hlslKeywordMap)["bool3x3"] =                 EHTokBool3x3;
+    (*hlslKeywordMap)["bool3x4"] =                 EHTokBool3x4;
+    (*hlslKeywordMap)["bool4x1"] =                 EHTokBool4x1;
+    (*hlslKeywordMap)["bool4x2"] =                 EHTokBool4x2;
+    (*hlslKeywordMap)["bool4x3"] =                 EHTokBool4x3;
+    (*hlslKeywordMap)["bool4x4"] =                 EHTokBool4x4;
+    (*hlslKeywordMap)["int1x1"] =                  EHTokInt1x1;
+    (*hlslKeywordMap)["int1x2"] =                  EHTokInt1x2;
+    (*hlslKeywordMap)["int1x3"] =                  EHTokInt1x3;
+    (*hlslKeywordMap)["int1x4"] =                  EHTokInt1x4;
+    (*hlslKeywordMap)["int2x1"] =                  EHTokInt2x1;
+    (*hlslKeywordMap)["int2x2"] =                  EHTokInt2x2;
+    (*hlslKeywordMap)["int2x3"] =                  EHTokInt2x3;
+    (*hlslKeywordMap)["int2x4"] =                  EHTokInt2x4;
+    (*hlslKeywordMap)["int3x1"] =                  EHTokInt3x1;
+    (*hlslKeywordMap)["int3x2"] =                  EHTokInt3x2;
+    (*hlslKeywordMap)["int3x3"] =                  EHTokInt3x3;
+    (*hlslKeywordMap)["int3x4"] =                  EHTokInt3x4;
+    (*hlslKeywordMap)["int4x1"] =                  EHTokInt4x1;
+    (*hlslKeywordMap)["int4x2"] =                  EHTokInt4x2;
+    (*hlslKeywordMap)["int4x3"] =                  EHTokInt4x3;
+    (*hlslKeywordMap)["int4x4"] =                  EHTokInt4x4;
+    (*hlslKeywordMap)["uint1x1"] =                 EHTokUint1x1;
+    (*hlslKeywordMap)["uint1x2"] =                 EHTokUint1x2;
+    (*hlslKeywordMap)["uint1x3"] =                 EHTokUint1x3;
+    (*hlslKeywordMap)["uint1x4"] =                 EHTokUint1x4;
+    (*hlslKeywordMap)["uint2x1"] =                 EHTokUint2x1;
+    (*hlslKeywordMap)["uint2x2"] =                 EHTokUint2x2;
+    (*hlslKeywordMap)["uint2x3"] =                 EHTokUint2x3;
+    (*hlslKeywordMap)["uint2x4"] =                 EHTokUint2x4;
+    (*hlslKeywordMap)["uint3x1"] =                 EHTokUint3x1;
+    (*hlslKeywordMap)["uint3x2"] =                 EHTokUint3x2;
+    (*hlslKeywordMap)["uint3x3"] =                 EHTokUint3x3;
+    (*hlslKeywordMap)["uint3x4"] =                 EHTokUint3x4;
+    (*hlslKeywordMap)["uint4x1"] =                 EHTokUint4x1;
+    (*hlslKeywordMap)["uint4x2"] =                 EHTokUint4x2;
+    (*hlslKeywordMap)["uint4x3"] =                 EHTokUint4x3;
+    (*hlslKeywordMap)["uint4x4"] =                 EHTokUint4x4;
+    (*hlslKeywordMap)["bool1x1"] =                 EHTokBool1x1;
+    (*hlslKeywordMap)["bool1x2"] =                 EHTokBool1x2;
+    (*hlslKeywordMap)["bool1x3"] =                 EHTokBool1x3;
+    (*hlslKeywordMap)["bool1x4"] =                 EHTokBool1x4;
+    (*hlslKeywordMap)["bool2x1"] =                 EHTokBool2x1;
+    (*hlslKeywordMap)["bool2x2"] =                 EHTokBool2x2;
+    (*hlslKeywordMap)["bool2x3"] =                 EHTokBool2x3;
+    (*hlslKeywordMap)["bool2x4"] =                 EHTokBool2x4;
+    (*hlslKeywordMap)["bool3x1"] =                 EHTokBool3x1;
+    (*hlslKeywordMap)["bool3x2"] =                 EHTokBool3x2;
+    (*hlslKeywordMap)["bool3x3"] =                 EHTokBool3x3;
+    (*hlslKeywordMap)["bool3x4"] =                 EHTokBool3x4;
+    (*hlslKeywordMap)["bool4x1"] =                 EHTokBool4x1;
+    (*hlslKeywordMap)["bool4x2"] =                 EHTokBool4x2;
+    (*hlslKeywordMap)["bool4x3"] =                 EHTokBool4x3;
+    (*hlslKeywordMap)["bool4x4"] =                 EHTokBool4x4;
+    (*hlslKeywordMap)["float1x1"] =                EHTokFloat1x1;
+    (*hlslKeywordMap)["float1x2"] =                EHTokFloat1x2;
+    (*hlslKeywordMap)["float1x3"] =                EHTokFloat1x3;
+    (*hlslKeywordMap)["float1x4"] =                EHTokFloat1x4;
+    (*hlslKeywordMap)["float2x1"] =                EHTokFloat2x1;
+    (*hlslKeywordMap)["float2x2"] =                EHTokFloat2x2;
+    (*hlslKeywordMap)["float2x3"] =                EHTokFloat2x3;
+    (*hlslKeywordMap)["float2x4"] =                EHTokFloat2x4;
+    (*hlslKeywordMap)["float3x1"] =                EHTokFloat3x1;
+    (*hlslKeywordMap)["float3x2"] =                EHTokFloat3x2;
+    (*hlslKeywordMap)["float3x3"] =                EHTokFloat3x3;
+    (*hlslKeywordMap)["float3x4"] =                EHTokFloat3x4;
+    (*hlslKeywordMap)["float4x1"] =                EHTokFloat4x1;
+    (*hlslKeywordMap)["float4x2"] =                EHTokFloat4x2;
+    (*hlslKeywordMap)["float4x3"] =                EHTokFloat4x3;
+    (*hlslKeywordMap)["float4x4"] =                EHTokFloat4x4;
+    (*hlslKeywordMap)["half1x1"] =                 EHTokHalf1x1;
+    (*hlslKeywordMap)["half1x2"] =                 EHTokHalf1x2;
+    (*hlslKeywordMap)["half1x3"] =                 EHTokHalf1x3;
+    (*hlslKeywordMap)["half1x4"] =                 EHTokHalf1x4;
+    (*hlslKeywordMap)["half2x1"] =                 EHTokHalf2x1;
+    (*hlslKeywordMap)["half2x2"] =                 EHTokHalf2x2;
+    (*hlslKeywordMap)["half2x3"] =                 EHTokHalf2x3;
+    (*hlslKeywordMap)["half2x4"] =                 EHTokHalf2x4;
+    (*hlslKeywordMap)["half3x1"] =                 EHTokHalf3x1;
+    (*hlslKeywordMap)["half3x2"] =                 EHTokHalf3x2;
+    (*hlslKeywordMap)["half3x3"] =                 EHTokHalf3x3;
+    (*hlslKeywordMap)["half3x4"] =                 EHTokHalf3x4;
+    (*hlslKeywordMap)["half4x1"] =                 EHTokHalf4x1;
+    (*hlslKeywordMap)["half4x2"] =                 EHTokHalf4x2;
+    (*hlslKeywordMap)["half4x3"] =                 EHTokHalf4x3;
+    (*hlslKeywordMap)["half4x4"] =                 EHTokHalf4x4;
+    (*hlslKeywordMap)["double1x1"] =               EHTokDouble1x1;
+    (*hlslKeywordMap)["double1x2"] =               EHTokDouble1x2;
+    (*hlslKeywordMap)["double1x3"] =               EHTokDouble1x3;
+    (*hlslKeywordMap)["double1x4"] =               EHTokDouble1x4;
+    (*hlslKeywordMap)["double2x1"] =               EHTokDouble2x1;
+    (*hlslKeywordMap)["double2x2"] =               EHTokDouble2x2;
+    (*hlslKeywordMap)["double2x3"] =               EHTokDouble2x3;
+    (*hlslKeywordMap)["double2x4"] =               EHTokDouble2x4;
+    (*hlslKeywordMap)["double3x1"] =               EHTokDouble3x1;
+    (*hlslKeywordMap)["double3x2"] =               EHTokDouble3x2;
+    (*hlslKeywordMap)["double3x3"] =               EHTokDouble3x3;
+    (*hlslKeywordMap)["double3x4"] =               EHTokDouble3x4;
+    (*hlslKeywordMap)["double4x1"] =               EHTokDouble4x1;
+    (*hlslKeywordMap)["double4x2"] =               EHTokDouble4x2;
+    (*hlslKeywordMap)["double4x3"] =               EHTokDouble4x3;
+    (*hlslKeywordMap)["double4x4"] =               EHTokDouble4x4;
+
+    (*hlslKeywordMap)["sampler"] =                 EHTokSampler;
+    (*hlslKeywordMap)["sampler1D"] =               EHTokSampler1d;
+    (*hlslKeywordMap)["sampler2D"] =               EHTokSampler2d;
+    (*hlslKeywordMap)["sampler3D"] =               EHTokSampler3d;
+    (*hlslKeywordMap)["samplerCube"] =             EHTokSamplerCube;
+    (*hlslKeywordMap)["sampler_state"] =           EHTokSamplerState;
+    (*hlslKeywordMap)["SamplerState"] =            EHTokSamplerState;
+    (*hlslKeywordMap)["SamplerComparisonState"] =  EHTokSamplerComparisonState;
+    (*hlslKeywordMap)["texture"] =                 EHTokTexture;
+    (*hlslKeywordMap)["Texture1D"] =               EHTokTexture1d;
+    (*hlslKeywordMap)["Texture1DArray"] =          EHTokTexture1darray;
+    (*hlslKeywordMap)["Texture2D"] =               EHTokTexture2d;
+    (*hlslKeywordMap)["Texture2DArray"] =          EHTokTexture2darray;
+    (*hlslKeywordMap)["Texture3D"] =               EHTokTexture3d;
+    (*hlslKeywordMap)["TextureCube"] =             EHTokTextureCube;
+    (*hlslKeywordMap)["TextureCubeArray"] =        EHTokTextureCubearray;
+    (*hlslKeywordMap)["Texture2DMS"] =             EHTokTexture2DMS;
+    (*hlslKeywordMap)["Texture2DMSArray"] =        EHTokTexture2DMSarray;
+    (*hlslKeywordMap)["RWTexture1D"] =             EHTokRWTexture1d;
+    (*hlslKeywordMap)["RWTexture1DArray"] =        EHTokRWTexture1darray;
+    (*hlslKeywordMap)["RWTexture2D"] =             EHTokRWTexture2d;
+    (*hlslKeywordMap)["RWTexture2DArray"] =        EHTokRWTexture2darray;
+    (*hlslKeywordMap)["RWTexture3D"] =             EHTokRWTexture3d;
+    (*hlslKeywordMap)["RWBuffer"] =                EHTokRWBuffer;
+    (*hlslKeywordMap)["SubpassInput"] =            EHTokSubpassInput;
+    (*hlslKeywordMap)["SubpassInputMS"] =          EHTokSubpassInputMS;
+
+    (*hlslKeywordMap)["AppendStructuredBuffer"] =  EHTokAppendStructuredBuffer;
+    (*hlslKeywordMap)["ByteAddressBuffer"] =       EHTokByteAddressBuffer;
+    (*hlslKeywordMap)["ConsumeStructuredBuffer"] = EHTokConsumeStructuredBuffer;
+    (*hlslKeywordMap)["RWByteAddressBuffer"] =     EHTokRWByteAddressBuffer;
+    (*hlslKeywordMap)["RWStructuredBuffer"] =      EHTokRWStructuredBuffer;
+    (*hlslKeywordMap)["StructuredBuffer"] =        EHTokStructuredBuffer;
+    (*hlslKeywordMap)["TextureBuffer"] =           EHTokTextureBuffer;
+
+    (*hlslKeywordMap)["class"] =                   EHTokClass;
+    (*hlslKeywordMap)["struct"] =                  EHTokStruct;
+    (*hlslKeywordMap)["cbuffer"] =                 EHTokCBuffer;
+    (*hlslKeywordMap)["ConstantBuffer"] =          EHTokConstantBuffer;
+    (*hlslKeywordMap)["tbuffer"] =                 EHTokTBuffer;
+    (*hlslKeywordMap)["typedef"] =                 EHTokTypedef;
+    (*hlslKeywordMap)["this"] =                    EHTokThis;
+    (*hlslKeywordMap)["namespace"] =               EHTokNamespace;
+
+    (*hlslKeywordMap)["true"] =                    EHTokBoolConstant;
+    (*hlslKeywordMap)["false"] =                   EHTokBoolConstant;
+
+    (*hlslKeywordMap)["for"] =                     EHTokFor;
+    (*hlslKeywordMap)["do"] =                      EHTokDo;
+    (*hlslKeywordMap)["while"] =                   EHTokWhile;
+    (*hlslKeywordMap)["break"] =                   EHTokBreak;
+    (*hlslKeywordMap)["continue"] =                EHTokContinue;
+    (*hlslKeywordMap)["if"] =                      EHTokIf;
+    (*hlslKeywordMap)["else"] =                    EHTokElse;
+    (*hlslKeywordMap)["discard"] =                 EHTokDiscard;
+    (*hlslKeywordMap)["return"] =                  EHTokReturn;
+    (*hlslKeywordMap)["switch"] =                  EHTokSwitch;
+    (*hlslKeywordMap)["case"] =                    EHTokCase;
+    (*hlslKeywordMap)["default"] =                 EHTokDefault;
 
     // TODO: get correct set here
-    ReservedSet = new std::unordered_set<const char*, str_hash, str_eq>;
-
-    ReservedSet->insert("auto");
-    ReservedSet->insert("catch");
-    ReservedSet->insert("char");
-    ReservedSet->insert("const_cast");
-    ReservedSet->insert("enum");
-    ReservedSet->insert("explicit");
-    ReservedSet->insert("friend");
-    ReservedSet->insert("goto");
-    ReservedSet->insert("long");
-    ReservedSet->insert("mutable");
-    ReservedSet->insert("new");
-    ReservedSet->insert("operator");
-    ReservedSet->insert("private");
-    ReservedSet->insert("protected");
-    ReservedSet->insert("public");
-    ReservedSet->insert("reinterpret_cast");
-    ReservedSet->insert("short");
-    ReservedSet->insert("signed");
-    ReservedSet->insert("sizeof");
-    ReservedSet->insert("static_cast");
-    ReservedSet->insert("template");
-    ReservedSet->insert("throw");
-    ReservedSet->insert("try");
-    ReservedSet->insert("typename");
-    ReservedSet->insert("union");
-    ReservedSet->insert("unsigned");
-    ReservedSet->insert("using");
-    ReservedSet->insert("virtual");
-
-    SemanticMap = new std::unordered_map<const char*, glslang::TBuiltInVariable, str_hash, str_eq>;
+    hlslReservedSet = new std::unordered_set<const char*, str_hash, str_eq>;
+
+    hlslReservedSet->insert("auto");
+    hlslReservedSet->insert("catch");
+    hlslReservedSet->insert("char");
+    hlslReservedSet->insert("const_cast");
+    hlslReservedSet->insert("enum");
+    hlslReservedSet->insert("explicit");
+    hlslReservedSet->insert("friend");
+    hlslReservedSet->insert("goto");
+    hlslReservedSet->insert("long");
+    hlslReservedSet->insert("mutable");
+    hlslReservedSet->insert("new");
+    hlslReservedSet->insert("operator");
+    hlslReservedSet->insert("private");
+    hlslReservedSet->insert("protected");
+    hlslReservedSet->insert("public");
+    hlslReservedSet->insert("reinterpret_cast");
+    hlslReservedSet->insert("short");
+    hlslReservedSet->insert("signed");
+    hlslReservedSet->insert("sizeof");
+    hlslReservedSet->insert("static_cast");
+    hlslReservedSet->insert("template");
+    hlslReservedSet->insert("throw");
+    hlslReservedSet->insert("try");
+    hlslReservedSet->insert("typename");
+    hlslReservedSet->insert("union");
+    hlslReservedSet->insert("unsigned");
+    hlslReservedSet->insert("using");
+    hlslReservedSet->insert("virtual");
+
+    hlslSemanticMap = new std::unordered_map<const char*, glslang::TBuiltInVariable, str_hash, str_eq>;
 
     // in DX9, all outputs had to have a semantic associated with them, that was either consumed
     // by the system or was a specific register assignment
@@ -416,45 +394,45 @@ void HlslScanContext::fillInKeywordMap()
     // to the next
     bool bParseDX9 = false;
     if (bParseDX9) {
-        (*SemanticMap)["PSIZE"] = EbvPointSize;
-        (*SemanticMap)["FOG"] =   EbvFogFragCoord;
-        (*SemanticMap)["DEPTH"] = EbvFragDepth;
-        (*SemanticMap)["VFACE"] = EbvFace;
-        (*SemanticMap)["VPOS"] =  EbvFragCoord;
+        (*hlslSemanticMap)["PSIZE"] = EbvPointSize;
+        (*hlslSemanticMap)["FOG"] =   EbvFogFragCoord;
+        (*hlslSemanticMap)["DEPTH"] = EbvFragDepth;
+        (*hlslSemanticMap)["VFACE"] = EbvFace;
+        (*hlslSemanticMap)["VPOS"] =  EbvFragCoord;
     }
 
-    (*SemanticMap)["SV_POSITION"] =               EbvPosition;
-    (*SemanticMap)["SV_VERTEXID"] =               EbvVertexIndex;
-    (*SemanticMap)["SV_VIEWPORTARRAYINDEX"] =     EbvViewportIndex;
-    (*SemanticMap)["SV_TESSFACTOR"] =             EbvTessLevelOuter;
-    (*SemanticMap)["SV_SAMPLEINDEX"] =            EbvSampleId;
-    (*SemanticMap)["SV_RENDERTARGETARRAYINDEX"] = EbvLayer;
-    (*SemanticMap)["SV_PRIMITIVEID"] =            EbvPrimitiveId;
-    (*SemanticMap)["SV_OUTPUTCONTROLPOINTID"] =   EbvInvocationId;
-    (*SemanticMap)["SV_ISFRONTFACE"] =            EbvFace;
-    (*SemanticMap)["SV_INSTANCEID"] =             EbvInstanceIndex;
-    (*SemanticMap)["SV_INSIDETESSFACTOR"] =       EbvTessLevelInner;
-    (*SemanticMap)["SV_GSINSTANCEID"] =           EbvInvocationId;
-    (*SemanticMap)["SV_DISPATCHTHREADID"] =       EbvGlobalInvocationId;
-    (*SemanticMap)["SV_GROUPTHREADID"] =          EbvLocalInvocationId;
-    (*SemanticMap)["SV_GROUPINDEX"] =             EbvLocalInvocationIndex;
-    (*SemanticMap)["SV_GROUPID"] =                EbvWorkGroupId;
-    (*SemanticMap)["SV_DOMAINLOCATION"] =         EbvTessCoord;
-    (*SemanticMap)["SV_DEPTH"] =                  EbvFragDepth;
-    (*SemanticMap)["SV_COVERAGE"] =               EbvSampleMask;
-    (*SemanticMap)["SV_DEPTHGREATEREQUAL"] =      EbvFragDepthGreater;
-    (*SemanticMap)["SV_DEPTHLESSEQUAL"] =         EbvFragDepthLesser;
-    (*SemanticMap)["SV_STENCILREF"] =             EbvFragStencilRef;
+    (*hlslSemanticMap)["SV_POSITION"] =               EbvPosition;
+    (*hlslSemanticMap)["SV_VERTEXID"] =               EbvVertexIndex;
+    (*hlslSemanticMap)["SV_VIEWPORTARRAYINDEX"] =     EbvViewportIndex;
+    (*hlslSemanticMap)["SV_TESSFACTOR"] =             EbvTessLevelOuter;
+    (*hlslSemanticMap)["SV_SAMPLEINDEX"] =            EbvSampleId;
+    (*hlslSemanticMap)["SV_RENDERTARGETARRAYINDEX"] = EbvLayer;
+    (*hlslSemanticMap)["SV_PRIMITIVEID"] =            EbvPrimitiveId;
+    (*hlslSemanticMap)["SV_OUTPUTCONTROLPOINTID"] =   EbvInvocationId;
+    (*hlslSemanticMap)["SV_ISFRONTFACE"] =            EbvFace;
+    (*hlslSemanticMap)["SV_INSTANCEID"] =             EbvInstanceIndex;
+    (*hlslSemanticMap)["SV_INSIDETESSFACTOR"] =       EbvTessLevelInner;
+    (*hlslSemanticMap)["SV_GSINSTANCEID"] =           EbvInvocationId;
+    (*hlslSemanticMap)["SV_DISPATCHTHREADID"] =       EbvGlobalInvocationId;
+    (*hlslSemanticMap)["SV_GROUPTHREADID"] =          EbvLocalInvocationId;
+    (*hlslSemanticMap)["SV_GROUPINDEX"] =             EbvLocalInvocationIndex;
+    (*hlslSemanticMap)["SV_GROUPID"] =                EbvWorkGroupId;
+    (*hlslSemanticMap)["SV_DOMAINLOCATION"] =         EbvTessCoord;
+    (*hlslSemanticMap)["SV_DEPTH"] =                  EbvFragDepth;
+    (*hlslSemanticMap)["SV_COVERAGE"] =               EbvSampleMask;
+    (*hlslSemanticMap)["SV_DEPTHGREATEREQUAL"] =      EbvFragDepthGreater;
+    (*hlslSemanticMap)["SV_DEPTHLESSEQUAL"] =         EbvFragDepthLesser;
+    (*hlslSemanticMap)["SV_STENCILREF"] =             EbvFragStencilRef;
 }
 
 void HlslScanContext::deleteKeywordMap()
 {
-    delete KeywordMap;
-    KeywordMap = nullptr;
-    delete ReservedSet;
-    ReservedSet = nullptr;
-    delete SemanticMap;
-    SemanticMap = nullptr;
+    delete hlslKeywordMap;
+    hlslKeywordMap = nullptr;
+    delete hlslReservedSet;
+    hlslReservedSet = nullptr;
+    delete hlslSemanticMap;
+    hlslSemanticMap = nullptr;
 }
 
 // Wrapper for tokenizeClass() to get everything inside the token.
@@ -466,8 +444,8 @@ void HlslScanContext::tokenize(HlslToken& token)
 
 glslang::TBuiltInVariable HlslScanContext::mapSemantic(const char* upperCase)
 {
-    auto it = SemanticMap->find(upperCase);
-    if (it != SemanticMap->end())
+    auto it = hlslSemanticMap->find(upperCase);
+    if (it != hlslSemanticMap->end())
         return it->second;
     else
         return glslang::EbvNone;
@@ -516,7 +494,7 @@ EHlslTokenClass HlslScanContext::tokenizeClass(HlslToken& token)
         case '{':                       return EHTokLeftBrace;
         case '}':                       return EHTokRightBrace;
         case '\\':
-            parseContext.error(loc, "illegal use of escape character", "\\", "");
+            _parseContext.error(loc, "illegal use of escape character", "\\", "");
             break;
 
         case PPAtomAddAssign:          return EHTokAddAssign;
@@ -571,11 +549,11 @@ EHlslTokenClass HlslScanContext::tokenizeClass(HlslToken& token)
                 char buf[2];
                 buf[0] = (char)token;
                 buf[1] = 0;
-                parseContext.error(loc, "unexpected token", buf, "");
+                _parseContext.error(loc, "unexpected token", buf, "");
             } else if (tokenText[0] != 0)
-                parseContext.error(loc, "unexpected token", tokenText, "");
+                _parseContext.error(loc, "unexpected token", tokenText, "");
             else
-                parseContext.error(loc, "unexpected token", "", "");
+                _parseContext.error(loc, "unexpected token", "", "");
             break;
         }
     } while (true);
@@ -583,11 +561,11 @@ EHlslTokenClass HlslScanContext::tokenizeClass(HlslToken& token)
 
 EHlslTokenClass HlslScanContext::tokenizeIdentifier()
 {
-    if (ReservedSet->find(tokenText) != ReservedSet->end())
+    if (hlslReservedSet->find(tokenText) != hlslReservedSet->end())
         return reservedWord();
 
-    auto it = KeywordMap->find(tokenText);
-    if (it == KeywordMap->end()) {
+    auto it = hlslKeywordMap->find(tokenText);
+    if (it == hlslKeywordMap->end()) {
         // Should have an identifier of some sort
         return identifierOrType();
     }
@@ -877,7 +855,7 @@ EHlslTokenClass HlslScanContext::tokenizeIdentifier()
         return keyword;
 
     default:
-        parseContext.infoSink.info.message(EPrefixInternalError, "Unknown glslang keyword", loc);
+        _parseContext.infoSink.info.message(EPrefixInternalError, "Unknown glslang keyword", loc);
         return EHTokNone;
     }
 }
@@ -894,8 +872,8 @@ EHlslTokenClass HlslScanContext::identifierOrType()
 // extension support before the extension is enabled.
 EHlslTokenClass HlslScanContext::reservedWord()
 {
-    if (! parseContext.symbolTable.atBuiltInLevel())
-        parseContext.error(loc, "Reserved word.", tokenText, "", "");
+    if (! _parseContext.symbolTable.atBuiltInLevel())
+        _parseContext.error(loc, "Reserved word.", tokenText, "", "");
 
     return EHTokNone;
 }
diff --git a/deps/glslang/glslang/hlsl/hlslScanContext.h b/deps/glslang/glslang/hlsl/hlslScanContext.h
index 9d30a12e1e..f7912c8d9b 100755
--- a/deps/glslang/glslang/hlsl/hlslScanContext.h
+++ b/deps/glslang/glslang/hlsl/hlslScanContext.h
@@ -73,8 +73,8 @@ struct HlslToken {
 //
 class HlslScanContext {
 public:
-    HlslScanContext(TParseContextBase& parseContext, TPpContext& ppContext)
-        : parseContext(parseContext), ppContext(ppContext) { }
+    HlslScanContext(TParseContextBase& _parseContext, TPpContext& ppContext)
+        : _parseContext(_parseContext), ppContext(ppContext) { }
     virtual ~HlslScanContext() { }
 
     static void fillInKeywordMap();
@@ -94,7 +94,7 @@ protected:
     EHlslTokenClass identifierOrReserved(bool reserved);
     EHlslTokenClass nonreservedKeyword(int version);
 
-    TParseContextBase& parseContext;
+    TParseContextBase& _parseContext;
     TPpContext& ppContext;
     TSourceLoc loc;
     TPpToken* ppToken;
